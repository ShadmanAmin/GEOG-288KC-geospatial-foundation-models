<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Working with Geospatial Raster Data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/quarto-contrib/fontawesome6-1.2.0/all.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/fontawesome6-1.2.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Building<br>GFMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">🏠 home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../Syllabus.html"> 
<span class="menu-text">📋 syllabus</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-chapters" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📚 chapters</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-chapters">    
        <li>
    <a class="dropdown-item" href="../../course-materials/week1.html">
 <span class="dropdown-text">1️⃣ Week 1 - Geospatial Data Foundations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/week2.html">
 <span class="dropdown-text">2️⃣ Week 2 - Spatial-Temporal Attention Mechanisms</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/week3.html">
 <span class="dropdown-text">3️⃣ Week 3 - Complete GFM Architecture</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/week4.html">
 <span class="dropdown-text">4️⃣ Week 4 - Pretraining Implementation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/week5.html">
 <span class="dropdown-text">5️⃣ Week 5 - Training Loop Optimization</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/week6.html">
 <span class="dropdown-text">6️⃣ Week 6 - Model Evaluation &amp; Analysis</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/week7.html">
 <span class="dropdown-text">7️⃣ Week 7 - Integration with Existing Models</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/week8.html">
 <span class="dropdown-text">8️⃣ Week 8 - Task-Specific Fine-tuning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/week9.html">
 <span class="dropdown-text">9️⃣ Week 9 - Model Implementation &amp; Deployment</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/week10.html">
 <span class="dropdown-text">🎯 Week 10 - Project Presentations &amp; Synthesis</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-weekly-sessions" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">💻 weekly sessions</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-weekly-sessions">    
        <li>
    <a class="dropdown-item" href="../../course-materials/weekly-sessions/session1_data_foundations_restructured.html">
 <span class="dropdown-text">Session 1 - 📊 Geospatial Data Foundations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/weekly-sessions/session2_attention_mechanisms.html">
 <span class="dropdown-text">Session 2 - 🧠 Spatial-Temporal Attention Mechanisms</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/weekly-sessions/session3_architecture.html">
 <span class="dropdown-text">Session 3 - 🏗️ Complete GFM Architecture</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/weekly-sessions/session4_pretraining.html">
 <span class="dropdown-text">Session 4 - 🔥 Pretraining Implementation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/weekly-sessions/session5_training_loop.html">
 <span class="dropdown-text">Session 5 - ⚙️ Training Loop Optimization</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/weekly-sessions/session6_evaluation.html">
 <span class="dropdown-text">Session 6 - 📈 Model Evaluation &amp; Analysis</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/weekly-sessions/session7_pretrained_integration.html">
 <span class="dropdown-text">Session 7 - 🤝 Integration with Existing Models</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/weekly-sessions/session8_finetuning.html">
 <span class="dropdown-text">Session 8 - 🔧 Task-Specific Fine-tuning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/weekly-sessions/session9_deployment.html">
 <span class="dropdown-text">Session 9 - ☁️ Model Implementation &amp; Deployment</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/weekly-sessions/session10_presentations.html">
 <span class="dropdown-text">Session 10 - 🎯 Project Presentations &amp; Synthesis</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-extras" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">📖 extras</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-extras">    
        <li class="dropdown-header">📚 Reference Materials</li>
        <li>
    <a class="dropdown-item" href="../../cheatsheets.html">
 <span class="dropdown-text">Cheatsheets</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/resources/course_resources.html">
 <span class="dropdown-text">Course Resources</span></a>
  </li>  
        <li class="dropdown-header">🎯 Practical Examples</li>
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/examples/normalization_comparison.html">
 <span class="dropdown-text">Normalization Comparison</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/examples/resnet.html">
 <span class="dropdown-text">ResNet Implementation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/examples/text_encoder.html">
 <span class="dropdown-text">Text Encoder</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/examples/tiling-and-patches.html">
 <span class="dropdown-text">Tiling and Patches</span></a>
  </li>  
        <li class="dropdown-header">🎓 Lectures</li>
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/lectures/lecture1_architectures.html">
 <span class="dropdown-text">Foundation Model Architectures</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/lectures/lecture2_geospatial_data.html">
 <span class="dropdown-text">Geospatial Data &amp; Remote Sensing</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/lectures/lecture3_finetuning.html">
 <span class="dropdown-text">Fine-tuning Strategies</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/lectures/lecture4_multimodal.html">
 <span class="dropdown-text">Multi-modal Learning</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/lectures/lecture5_evaluation.html">
 <span class="dropdown-text">Model Evaluation &amp; Validation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/lectures/lecture6_cloud_computing.html">
 <span class="dropdown-text">Cloud &amp; Scalable Computing</span></a>
  </li>  
        <li class="dropdown-header">📁 Project Templates</li>
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/projects/project-application-template.html">
 <span class="dropdown-text">Project Application Template</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/projects/project-proposal-template.html">
 <span class="dropdown-text">Project Proposal Template</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../course-materials/extras/projects/mvp-template.html">
 <span class="dropdown-text">MVP Presentation Template</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kellycaylor/geoAI" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <div class="quarto-title-block"><div><h1 class="title">Working with Geospatial Raster Data</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
            <p class="subtitle lead">From raw rasters to model‑ready embeddings, step by step</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta column-page-left">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#learning-objectives" id="toc-learning-objectives" class="nav-link" data-scroll-target="#learning-objectives">Learning Objectives</a></li>
  <li><a href="#session-roadmap" id="toc-session-roadmap" class="nav-link" data-scroll-target="#session-roadmap">Session Roadmap</a></li>
  <li><a href="#setting-up" id="toc-setting-up" class="nav-link" data-scroll-target="#setting-up">Setting Up</a></li>
  </ul></li>
  <li><a href="#phase-1-pixel-level-pre-processing" id="toc-phase-1-pixel-level-pre-processing" class="nav-link" data-scroll-target="#phase-1-pixel-level-pre-processing">🔬 Phase 1: Pixel-Level Pre-processing</a>
  <ul class="collapse">
  <li><a href="#raw-data-inspection" id="toc-raw-data-inspection" class="nav-link" data-scroll-target="#raw-data-inspection">1.1 🛰️ Raw Data Inspection</a></li>
  <li><a href="#band-normalization" id="toc-band-normalization" class="nav-link" data-scroll-target="#band-normalization">1.2 📐 Band Normalization</a></li>
  <li><a href="#tiling-and-patch-extraction" id="toc-tiling-and-patch-extraction" class="nav-link" data-scroll-target="#tiling-and-patch-extraction">1.3 Tiling and patch extraction ✂️</a></li>
  <li><a href="#assigning-patch-ids-metadata" id="toc-assigning-patch-ids-metadata" class="nav-link" data-scroll-target="#assigning-patch-ids-metadata">1.4 Assigning patch IDs &amp; metadata 🏷️</a></li>
  <li><a href="#adding-special-context-tokens-location-time-sensor" id="toc-adding-special-context-tokens-location-time-sensor" class="nav-link" data-scroll-target="#adding-special-context-tokens-location-time-sensor">1.5 Adding special context tokens (location, time, sensor) 🌍</a></li>
  <li><a href="#dimensionality-reduction-for-spectral-bands-analogy-to-bpe" id="toc-dimensionality-reduction-for-spectral-bands-analogy-to-bpe" class="nav-link" data-scroll-target="#dimensionality-reduction-for-spectral-bands-analogy-to-bpe">1.6 Dimensionality reduction for spectral bands (analogy to BPE)</a></li>
  <li><a href="#sampling-training-patches-sliding-windows-spatial-splits" id="toc-sampling-training-patches-sliding-windows-spatial-splits" class="nav-link" data-scroll-target="#sampling-training-patches-sliding-windows-spatial-splits">1.7 Sampling training patches (sliding windows, spatial splits)</a></li>
  <li><a href="#creating-patch-embeddings" id="toc-creating-patch-embeddings" class="nav-link" data-scroll-target="#creating-patch-embeddings">1.8 Creating patch embeddings 🧠</a></li>
  <li><a href="#encoding-spatial-temporal-positions" id="toc-encoding-spatial-temporal-positions" class="nav-link" data-scroll-target="#encoding-spatial-temporal-positions">1.9 Encoding spatial &amp; temporal positions 📍</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#resources" id="toc-resources" class="nav-link" data-scroll-target="#resources">Resources</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>In this session, we learn how to transform raw geospatial raster data into model‑ready embeddings. We’ll work with a tiny multi‑band GeoTIFF, build small, deterministic processing steps, and show visible outputs after every step. The goal is to build intuition that mirrors LLM pipelines (tokenization → embeddings) while grounding everything in images (patches → embeddings).</p>
<section id="learning-objectives" class="level2">
<h2 class="anchored" data-anchor-id="learning-objectives">Learning Objectives</h2>
<ul>
<li>Load and inspect small multi‑band rasters (CRS, resolution, dtype, bands)</li>
<li>Normalize and organize bands for consistent modeling</li>
<li>Extract fixed‑size patches</li>
<li>Add contextual features (location/time “tokens”)</li>
<li>Sample training patches correctly and create patch embeddings with shapes you can verify</li>
</ul>
</section>
<section id="session-roadmap" class="level2">
<h2 class="anchored" data-anchor-id="session-roadmap">Session Roadmap</h2>
<p>This session follows a complete data processing pipeline organized into three logical phases that transform raw satellite imagery into model-ready embeddings:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    subgraph Phase1 ["🔬 Phase 1: Pixel-Level Pre-processing"]
        direction LR
        A["🛰️ Raw Data&lt;br/&gt;Inspection&lt;br/&gt;Section 1.1"] --&gt; B["📐 Band&lt;br/&gt;Normalization&lt;br/&gt;Section 1.2"]
        B --&gt; C["🔬 Dimensionality&lt;br/&gt;Reduction&lt;br/&gt;Section 1.3"]
    end
    
    subgraph Phase2 ["🗺️ Phase 2: Spatial-Structure Processing"]
        direction LR
        D["✂️ Patch&lt;br/&gt;Extraction&lt;br/&gt;Section 2.1"] --&gt; E["🏷️ Patch&lt;br/&gt;Metadata&lt;br/&gt;Section 2.2"]
        E --&gt; F["🌍 Spatial-Temporal&lt;br/&gt;Context&lt;br/&gt;Section 2.3"]
        F --&gt; G["📊 Training&lt;br/&gt;Sampling&lt;br/&gt;Section 2.4"]
    end
    
    subgraph Phase3 ["🧠 Phase 3: Model-Ready Processing"]
        direction LR
        H["🧠 Patch&lt;br/&gt;Embeddings&lt;br/&gt;Section 3.1"] --&gt; I["📍 Positional&lt;br/&gt;Encoding&lt;br/&gt;Section 3.2"]
    end
    
    Phase1 --&gt; Phase2
    Phase2 --&gt; Phase3
    
    style Phase1 fill:#e3f2fd
    style Phase2 fill:#fff3e0  
    style Phase3 fill:#e8f5e8
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="setting-up" class="level2">
<h2 class="anchored" data-anchor-id="setting-up">Setting Up</h2>
<p>Before we get started, let’s setup our computational environment by loading necessary libraries and seeding our computations.</p>
<section id="load-required-libraries" class="level3">
<h3 class="anchored" data-anchor-id="load-required-libraries">Load required libraries</h3>
<p>Why these imports: file paths (Path), randomness (random, numpy), and plotting (matplotlib) are used throughout the session.</p>
<div id="cf2333c8" class="cell" data-execution_count="1">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os, random</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Imports OK"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Imports OK</code></pre>
</div>
</div>
</section>
<section id="set-random-number-generation-rng-seeds" class="level3">
<h3 class="anchored" data-anchor-id="set-random-number-generation-rng-seeds">Set Random Number Generation (RNG) seeds</h3>
<p>We use fixed seeds to ensure that our randomness is consistent every time we run our example code. This allows your results to match the rendered output on the course site.</p>
<div id="caee2b88" class="cell" data-execution_count="2">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>RNG_SEED <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>os.environ[<span class="st">"PYTHONHASHSEED"</span>] <span class="op">=</span> <span class="bu">str</span>(RNG_SEED)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>random.seed(RNG_SEED)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>np.random.seed(RNG_SEED)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Seeds set:"</span>, RNG_SEED)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Seeds set: 42</code></pre>
</div>
</div>
</section>
<section id="define-data-paths-and-constants" class="level3">
<h3 class="anchored" data-anchor-id="define-data-paths-and-constants">Define data paths and constants</h3>
<p>We’ll store the sample raster in a local <code>data/</code> directory and set a default patch size.</p>
<div id="ab884616" class="cell" data-execution_count="3">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use absolute path to ensure we find the data file</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>DATA_DIR <span class="op">=</span> Path(<span class="va">__file__</span>).parent.parent.parent.parent <span class="op">/</span> <span class="st">"data"</span> <span class="cf">if</span> <span class="st">"__file__"</span> <span class="kw">in</span> <span class="bu">globals</span>() <span class="cf">else</span> Path(<span class="st">"../../../data"</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>DATA_DIR.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>DATA_PATH <span class="op">=</span> DATA_DIR <span class="op">/</span> <span class="st">"landcover_sample.tif"</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>PATCH_SIZE <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"DATA_PATH:"</span>, DATA_PATH)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"DATA_PATH exists:"</span>, DATA_PATH.exists())</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Current working directory:"</span>, Path.cwd())</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"PATCH_SIZE:"</span>, PATCH_SIZE)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>DATA_PATH: ../../../data/landcover_sample.tif
DATA_PATH exists: True
Current working directory: /Users/kellycaylor/dev/geoAI/book/course-materials/weekly-sessions
PATCH_SIZE: 64</code></pre>
</div>
</div>
<p>If the file is missing, we’ll download a small sample.</p>
<div id="196c8b7f" class="cell" data-execution_count="4">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> DATA_PATH.exists():</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">FileNotFoundError</span>(<span class="ss">f"Data file not found at </span><span class="sc">{</span>DATA_PATH<span class="sc">}</span><span class="ss">. Please ensure the landcover_sample.tif file is available in the data directory."</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"✓ Data file found!"</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Path: </span><span class="sc">{</span>DATA_PATH<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Size (KB): </span><span class="sc">{</span><span class="bu">round</span>(DATA_PATH.stat().st_size<span class="op">/</span><span class="dv">1024</span>,<span class="dv">1</span>)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>✓ Data file found!
  Path: ../../../data/landcover_sample.tif
  Size (KB): 12.6</code></pre>
</div>
</div>
<hr>
</section>
</section>
</section>
<section id="phase-1-pixel-level-pre-processing" class="level1">
<h1>🔬 Phase 1: Pixel-Level Pre-processing</h1>
<p><em>In this phase, we work with the full image and operate on individual pixels. We’ll develop code to read our raw data, normalize it for consistent model training, and perform dimensionality reduction before moving to spatial operations.</em></p>
<section id="raw-data-inspection" class="level2">
<h2 class="anchored" data-anchor-id="raw-data-inspection">1.1 🛰️ Raw Data Inspection</h2>
<section id="reading-geospatial-data" class="level3">
<h3 class="anchored" data-anchor-id="reading-geospatial-data">Reading Geospatial Data</h3>
<p>Before we start working with the data in Python, it’s important to understand what kinds of information a geospatial raster dataset contains.</p>
<p>A single raster file stores <strong>two broad categories of information</strong>:</p>
<ol type="1">
<li><strong>Pixel values</strong> – the actual measurements.
<ul>
<li>Each pixel has one or more <strong>bands</strong> (channels) that store numeric values.<br>
</li>
<li>Bands might represent reflectance in different wavelengths, elevation, temperature, or derived indices like NDVI.<br>
</li>
<li>Pixel values are stored in a numeric data type (e.g., integers or floats) and have a defined range (min/max).</li>
</ul></li>
<li><strong>Spatial metadata</strong> – information that describes where and how those measurements fit on Earth.
<ul>
<li><strong>Location reference</strong> — how pixel positions map to real-world coordinates.<br>
</li>
<li><strong>Pixel resolution</strong> — the width and height of each pixel in ground units (e.g., meters).<br>
</li>
<li><strong>Grid layout and orientation</strong> — how rows and columns are aligned in space.<br>
</li>
<li><strong>Coordinate system</strong> — the mathematical model that defines positions on Earth (projection).<br>
</li>
<li><strong>Transform</strong> — a mapping from pixel coordinates (row/col) to real-world coordinates (x/y).</li>
</ul></li>
</ol>
<p>When we open a raster with <code>rasterio</code>, we can access <strong>both</strong> the measurement values and the spatial metadata. This lets us work with the data not just as an image, but as a set of geographically-anchored measurements we can relate to location, time, and other datasets. Let’s take a look at our sample image.</p>
</section>
<section id="rasterio-image-reading-and-metadata-inspection" class="level3">
<h3 class="anchored" data-anchor-id="rasterio-image-reading-and-metadata-inspection">Rasterio image reading and metadata inspection</h3>
<div id="458f1764" class="cell" data-execution_count="5">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio <span class="im">as</span> rio</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyproj</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> rio.<span class="bu">open</span>(DATA_PATH) <span class="im">as</span> src:</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> src.read()                          <span class="co"># (bands, height, width)</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    band_count, height, width <span class="op">=</span> arr.shape</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    dtype <span class="op">=</span> arr.dtype</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CRS and EPSG</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    crs <span class="op">=</span> src.crs</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    epsg <span class="op">=</span> crs.to_epsg()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    transform <span class="op">=</span> src.transform  <span class="co"># Save transform for later use</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get a human-readable CRS name</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    crs_info <span class="op">=</span> pyproj.CRS.from_user_input(crs)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    crs_name <span class="op">=</span> crs_info.name</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Resolution in CRS units</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    res_x, res_y <span class="op">=</span> src.res</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Print summary ---</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Shape: </span><span class="sc">{</span>arr<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Bands: </span><span class="sc">{</span>band_count<span class="sc">}</span><span class="ss">  |  Height: </span><span class="sc">{</span>height<span class="sc">}</span><span class="ss"> px  Width: </span><span class="sc">{</span>width<span class="sc">}</span><span class="ss"> px |  Data type: </span><span class="sc">{</span>dtype<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"CRS: </span><span class="sc">{</span>crs_name<span class="sc">}</span><span class="ss">"</span> <span class="op">+</span> (<span class="ss">f" (EPSG:</span><span class="sc">{</span>epsg<span class="sc">}</span><span class="ss">)"</span> <span class="cf">if</span> epsg <span class="cf">else</span> <span class="st">""</span>))</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Resolution: </span><span class="sc">{</span>res_x<span class="sc">:.2f}</span><span class="ss"> × </span><span class="sc">{</span>res_y<span class="sc">:.2f}</span><span class="ss"> ground units per pixel"</span>)</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Per-band min/max:"</span>)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, b <span class="kw">in</span> <span class="bu">enumerate</span>(arr, start<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Band </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span><span class="bu">float</span>(b.<span class="bu">min</span>())<span class="sc">:.3f}</span><span class="ss"> – </span><span class="sc">{</span><span class="bu">float</span>(b.<span class="bu">max</span>())<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Shape: (3, 64, 64)
Bands: 3  |  Height: 64 px  Width: 64 px |  Data type: uint8
CRS: Projection: Transverse Mercator; Datum: WGS84; Ellipsoid: WGS84
Resolution: 0.25 × 0.25 ground units per pixel
Per-band min/max:
  Band 1: 0.000 – 254.000
  Band 2: 0.000 – 254.000
  Band 3: 0.000 – 254.000</code></pre>
</div>
</div>
<p>Notice how the output gives us the fundamental “identity” of our geospatial data. The <code>arr.shape</code> tells us we have a 3D array(bands × height × width), the Coordinate Reference System (CRS) anchors this data to a specific location on Earth, and the resolution information tells us the real-world size of each pixel. Finally, the per-band min/max values reveal the dynamic range of our spectral measurements.</p>
<p>Although the pixel values in this image are stored as <code>uint8</code>, which supports a range from 0 to 255, all three bands in our dataset have maximum values of <code>254</code>. This usually happens because the largest possible value in the data type is often reserved as a <code>NoData</code> flag, marking pixels with no valid measurement. This upper limit is specific to this dataset, and the use of <code>NoData</code> flags is dataset dependent.</p>
<p>Image metadata is crucial because satellite imagery comes with precise spatial and spectral calibration. Each pixel value either represents actual physical measurements (like surface reflectance) at a specific geographic location, or a specific category that maps to a classification based on the dataset. Our model needs to understand not just “what values doe this pixel contain?” but also “where is this pixel?” and “what does this pixel represent?”</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Digital Numbers
</div>
</div>
<div class="callout-body-container callout-body">
<p>The raw pixel values in many geospatial images are stored as integers to reduce file size and improve processing speed. These integer values are called <strong>Digital Numbers</strong> (<code>DN</code>s).</p>
<p>A <code>DN</code> is an instrument-recorded value that may need to be scaled or converted to physical units (such as reflectance or temperature) before analysis.</p>
</div>
</div>
</section>
<section id="dn-visualization" class="level3">
<h3 class="anchored" data-anchor-id="dn-visualization">DN visualization</h3>
<div id="4734edcd" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display each band's raw DNs</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>num_bands <span class="op">=</span> arr.shape[<span class="dv">0</span>]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, num_bands, figsize<span class="op">=</span>(<span class="dv">4</span><span class="op">*</span>num_bands, <span class="dv">4</span>))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Handle case where we only have one band</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> num_bands <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    axes <span class="op">=</span> [axes]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_bands):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    band <span class="op">=</span> arr[i]</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    data_min, data_max <span class="op">=</span> <span class="bu">float</span>(band.<span class="bu">min</span>()), <span class="bu">float</span>(band.<span class="bu">max</span>())</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    im <span class="op">=</span> axes[i].imshow(band, cmap<span class="op">=</span><span class="st">'viridis'</span>, vmin<span class="op">=</span>data_min, vmax<span class="op">=</span>data_max)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    axes[i].set_title(<span class="ss">f"Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Raw Values</span><span class="ch">\n</span><span class="ss">(Range: </span><span class="sc">{</span>data_min<span class="sc">:.0f}</span><span class="ss"> - </span><span class="sc">{</span>data_max<span class="sc">:.0f}</span><span class="ss">)"</span>)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    axes[i].axis(<span class="st">'off'</span>)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add colorbar for each band</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    plt.colorbar(im, ax<span class="op">=</span>axes[i], label<span class="op">=</span><span class="st">'Digital Number (DN)'</span>, shrink<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="session1_data_foundations_original_files/figure-html/cell-7-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<hr>
</section>
</section>
<section id="band-normalization" class="level2">
<h2 class="anchored" data-anchor-id="band-normalization">1.2 📐 Band Normalization</h2>
<p><em>Scaling bands to consistent ranges for stable model training</em></p>
<p>Now that we’ve examined our raw data, we need to prepare it for neural network processing. While the raw digital numbers are meaningful for interpretation, they present several challenges when used directly as input to models. Different spectral bands often have vastly different value ranges, and <strong>neural networks are sensitive to the scale of input features</strong>.</p>
<section id="why-normalize-geospatial-data" class="level3">
<h3 class="anchored" data-anchor-id="why-normalize-geospatial-data">Why normalize geospatial data?</h3>
<p>Normalization serves several critical purposes in geospatial machine learning:</p>
<p><strong>Scale Invariance</strong>: Different spectral bands capture different physical phenomena and often have dramatically different value ranges. For example, near-infrared reflectance might range from 0-4000 DN, while visible bands range from 0-255 DN. Without normalization, the model would be dominated by the larger-valued bands.</p>
<p><strong>Training Stability</strong>: Neural networks use gradient-based optimization, which works best when input features have similar scales. Large differences in feature magnitude can cause unstable gradients, slow convergence, or poor performance.</p>
<p><strong>Sensor Consistency</strong>: When working with data from multiple sensors or time periods, normalization helps remove acquisition-specific biases while preserving the relative patterns that matter for learning.</p>
<p><strong>Activation Function Compatibility</strong>: Many neural network activation functions (like <code>sigmoid</code> or <code>tanh</code>) work optimally when inputs are in specific ranges. Normalized inputs help ensure we’re operating in the most effective part of these functions.</p>
</section>
<section id="common-normalization-approaches" class="level3">
<h3 class="anchored" data-anchor-id="common-normalization-approaches">Common normalization approaches</h3>
<p>Let’s examine the most common normalization strategies for geospatial data:</p>
<section id="min-max-normalization-what-well-use" class="level4">
<h4 class="anchored" data-anchor-id="min-max-normalization-what-well-use">Min-Max Normalization (what we’ll use)</h4>
<p>Scales each band to a fixed range, typically [0,1]:</p>
<pre><code>normalized = (value - min) / (max - min)</code></pre>
<p><strong>Pros</strong>: Preserves the distribution shape, guarantees output range<br>
<strong>Cons</strong>: Sensitive to outliers, range depends on specific dataset</p>
</section>
<section id="z-score-standardization" class="level4">
<h4 class="anchored" data-anchor-id="z-score-standardization">Z-Score Standardization</h4>
<p>Centers data around zero with unit variance:</p>
<pre><code>standardized = (value - mean) / std</code></pre>
<p><strong>Pros</strong>: Removes mean/variance effects, handles outliers better<br>
<strong>Cons</strong>: Output range is unbounded, can lose interpretability</p>
</section>
<section id="robust-scaling" class="level4">
<h4 class="anchored" data-anchor-id="robust-scaling">Robust Scaling</h4>
<p>Uses median and interquartile range instead of mean/std:</p>
<pre><code>robust = (value - median) / (75th_percentile - 25th_percentile)</code></pre>
<p><strong>Pros</strong>: Very robust to outliers<br>
<strong>Cons</strong>: More complex, can compress dynamic range</p>
<p>For this exercise, we’ll use min-max normalization because it’s intuitive and preserves the relative structure of our data while ensuring all bands contribute equally to the model.</p>
<div id="7f174c9a" class="cell" data-execution_count="7">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to float32 for numerical precision in calculations</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> arr.astype(np.float32)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Data type after conversion: </span><span class="sc">{</span>arr<span class="sc">.</span>dtype<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate per-band statistics</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Reshape to (bands, pixels) for easier computation</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>pixel_values <span class="op">=</span> arr.reshape(arr.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>mins <span class="op">=</span> pixel_values.<span class="bu">min</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>maxs <span class="op">=</span> pixel_values.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>ranges <span class="op">=</span> maxs <span class="op">-</span> mins</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Per-band statistics before normalization:"</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(mins)):</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: min=</span><span class="sc">{</span>mins[i]<span class="sc">:.1f}</span><span class="ss">, max=</span><span class="sc">{</span>maxs[i]<span class="sc">:.1f}</span><span class="ss">, range=</span><span class="sc">{</span>ranges[i]<span class="sc">:.1f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Data type after conversion: float32
Per-band statistics before normalization:
  Band 1: min=0.0, max=254.0, range=254.0
  Band 2: min=0.0, max=254.0, range=254.0
  Band 3: min=0.0, max=254.0, range=254.0</code></pre>
</div>
</div>
<div id="0c3ef50d" class="cell" data-execution_count="8">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply min-max normalization: (x - min) / (max - min)</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Add small epsilon to prevent division by zero</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>eps <span class="op">=</span> <span class="fl">1e-8</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>arr_norm <span class="op">=</span> (arr <span class="op">-</span> mins[:, <span class="va">None</span>, <span class="va">None</span>]) <span class="op">/</span> (np.maximum(ranges, eps)[:, <span class="va">None</span>, <span class="va">None</span>])</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Normalized to [0,1] range:"</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Per-band min/max after normalization:"</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, band <span class="kw">in</span> <span class="bu">enumerate</span>(arr_norm):</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span><span class="bu">float</span>(band.<span class="bu">min</span>())<span class="sc">:.3f}</span><span class="ss"> to </span><span class="sc">{</span><span class="bu">float</span>(band.<span class="bu">max</span>())<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Normalized to [0,1] range:
Per-band min/max after normalization:
  Band 1: 0.000 to 1.000
  Band 2: 0.000 to 1.000
  Band 3: 0.000 to 1.000</code></pre>
</div>
</div>
</section>
</section>
<section id="visualizing-the-normalization-effect" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-the-normalization-effect">Visualizing the normalization effect</h3>
<p>Let’s examine how normalization changes the distribution of pixel values. This visualization helps us understand both what we’ve gained (comparable scales) and what we’ve preserved (relative patterns within each band).</p>
<div id="3fce3a12" class="cell" data-execution_count="9">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare distributions before and after normalization</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">3</span>, arr.shape[<span class="dv">0</span>])):</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Raw data histogram</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].hist(arr[i].ravel(), bins<span class="op">=</span><span class="dv">50</span>, color<span class="op">=</span><span class="st">'gray'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_title(<span class="ss">f"Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Raw DNs"</span>)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_xlabel(<span class="st">"Digital Number"</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_ylabel(<span class="st">"Frequency"</span>)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Normalized data histogram  </span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].hist(arr_norm[i].ravel(), bins<span class="op">=</span><span class="dv">50</span>, color<span class="op">=</span><span class="st">'steelblue'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_title(<span class="ss">f"Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Normalized [0,1]"</span>)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_xlabel(<span class="st">"Normalized Value"</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_ylabel(<span class="st">"Frequency"</span>)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_xlim(<span class="dv">0</span>, <span class="dv">1</span>)  <span class="co"># Fix scale to show [0,1] range</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Distribution Comparison: Raw vs. Normalized"</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="session1_data_foundations_original_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Notice how the histograms show that while the scales have changed dramatically, the shape of each distribution—the relative patterns of light and dark areas—remains exactly the same. We’ve made the bands comparable without losing the information that distinguishes different materials and land cover types.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Historgram equalization
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>What to notice</strong></p>
<ul>
<li>The raw data shows very different scales across bands (different x-axis ranges)</li>
<li>After normalization, all bands span [0,1] but keep their unique distribution shapes</li>
<li>This transformation makes bands equally “visible” to the neural network while preserving the spectral signatures that matter for classification</li>
</ul>
</div>
</div>
<p>Why this matters: Proper normalization is essential for stable training and ensures all spectral bands contribute meaningfully to the model’s understanding of the landscape.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Deeper Dive: Normalization Method Comparison
</div>
</div>
<div class="callout-body-container callout-body">
<p>For a comprehensive analysis of different normalization approaches used in state-of-the-art geospatial foundation models (including Prithvi, SatMAE, and Clay), see our detailed <a href="../examples/normalization_comparison.qmd">Normalization Methods Comparison</a>. This example compares computational performance, robustness to outliers, and practical trade-offs between five different normalization strategies.</p>
</div>
</div>
<hr>
</section>
</section>
<section id="tiling-and-patch-extraction" class="level2">
<h2 class="anchored" data-anchor-id="tiling-and-patch-extraction">1.3 Tiling and patch extraction ✂️</h2>
<p><em>This section covers the patch extraction step in our roadmap: splitting large images into manageable “tokens” for model processing.</em></p>
<section id="why-do-we-need-patches" class="level3">
<h3 class="anchored" data-anchor-id="why-do-we-need-patches">Why do we need patches?</h3>
<p>When working with satellite imagery, we face a fundamental challenge: <strong>scale mismatch</strong>. A typical satellite image might be 10,000×10,000 pixels or larger, but neural networks work best with much smaller, consistent input sizes. But there’s more to it than just computational limits. Patches serve several critical functions in geospatial machine learning:</p>
<p><strong>🧠 Cognitive Focus</strong>: Just as humans focus on local areas when interpreting landscapes, neural networks learn more effectively when they can concentrate on coherent spatial neighborhoods rather than trying to process vast areas simultaneously.</p>
<p><strong>⚡ Computational Efficiency</strong>: Smaller patches fit in GPU memory and enable parallel processing. We can train on batches of patches rather than one massive image at a time.</p>
<p><strong>🎯 Consistent Learning</strong>: Fixed-size patches ensure the model sees consistent input dimensions, enabling it to learn spatial patterns at a specific scale.</p>
<p><strong>🔄 Data Augmentation</strong>: From one large image, we can extract hundreds or thousands of training patches, dramatically increasing our dataset size.</p>
</section>
<section id="the-tokenization-analogy" class="level3">
<h3 class="anchored" data-anchor-id="the-tokenization-analogy">The tokenization analogy</h3>
<p>The relationship between patches and tokenization runs deeper than you might first think. Let’s explore this analogy:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 17%">
<col style="width: 34%">
<col style="width: 47%">
</colgroup>
<thead>
<tr class="header">
<th>Aspect</th>
<th>Text Processing</th>
<th>Geospatial Processing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Raw Input</strong></td>
<td>Documents, articles, books</td>
<td>Large satellite images, map tiles</td>
</tr>
<tr class="even">
<td><strong>Atomic Unit</strong></td>
<td>Words/subwords → tokens</td>
<td>Pixels → patches</td>
</tr>
<tr class="odd">
<td><strong>Why Split?</strong></td>
<td>Models can’t process infinite text</td>
<td>Models can’t process arbitrarily large images</td>
</tr>
<tr class="even">
<td><strong>Context Window</strong></td>
<td>Limited token context (e.g., 4K tokens)</td>
<td>Limited spatial context (e.g., 64×64 pixels)</td>
</tr>
<tr class="odd">
<td><strong>Semantic Coherence</strong></td>
<td>Tokens preserve word meaning</td>
<td>Patches preserve local spatial patterns</td>
</tr>
<tr class="even">
<td><strong>Position Matters</strong></td>
<td>Word order affects meaning</td>
<td>Spatial arrangement affects interpretation</td>
</tr>
<tr class="odd">
<td><strong>Overlapping Context</strong></td>
<td>Sliding windows for long documents</td>
<td>Overlapping patches for spatial continuity</td>
</tr>
</tbody>
</table>
</section>
<section id="visualizing-the-patch-extraction-process" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-the-patch-extraction-process">Visualizing the patch extraction process</h3>
<p>Now we’ll implement the patch extraction step from our roadmap. This transforms our normalized image into a collection of spatial “tokens” that our model can process.</p>
</section>
<section id="understanding-patch-size-trade-offs" class="level3">
<h3 class="anchored" data-anchor-id="understanding-patch-size-trade-offs">Understanding patch size trade-offs</h3>
<p>Before we extract patches, it’s important to understand how patch size affects what our model can learn:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 30%">
<col style="width: 15%">
<col style="width: 15%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>Patch Size</th>
<th>Pros</th>
<th>Cons</th>
<th>Best Use Cases</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Small (16×16, 32×32)</strong></td>
<td>Fine detail, many samples, fast processing</td>
<td>Limited context, may miss large features</td>
<td>Urban analysis, crop monitoring</td>
</tr>
<tr class="even">
<td><strong>Medium (64×64, 128×128)</strong></td>
<td>Good balance of detail and context</td>
<td>Moderate computational cost</td>
<td>General purpose, land cover mapping</td>
</tr>
<tr class="odd">
<td><strong>Large (256×256, 512×512)</strong></td>
<td>Rich spatial context, captures large features</td>
<td>Fewer samples, more memory intensive</td>
<td>Landscape analysis, climate modeling</td>
</tr>
</tbody>
</table>
<p>For our exercise, we’ll use 64×64 patches—a sweet spot that captures meaningful spatial patterns while remaining computationally manageable.</p>
</section>
<section id="step-by-step-patch-extraction" class="level3">
<h3 class="anchored" data-anchor-id="step-by-step-patch-extraction">Step-by-step patch extraction</h3>
<p>Now let’s implement patch extraction with detailed visualization of each step:</p>
<div id="7804802c" class="cell" data-execution_count="10">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First, let's examine our normalized image dimensions</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>C, H, W <span class="op">=</span> arr_norm.shape</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Input image shape: </span><span class="sc">{</span>C<span class="sc">}</span><span class="ss"> bands × </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss"> height × </span><span class="sc">{</span>W<span class="sc">}</span><span class="ss"> width pixels"</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Using patch size: </span><span class="sc">{</span>PATCH_SIZE<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>PATCH_SIZE<span class="sc">}</span><span class="ss"> pixels"</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate how many complete patches we can extract</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>ph <span class="op">=</span> H <span class="op">//</span> PATCH_SIZE  <span class="co"># patches vertically</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>pw <span class="op">=</span> W <span class="op">//</span> PATCH_SIZE  <span class="co"># patches horizontally</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Complete patches: </span><span class="sc">{</span>ph<span class="sc">}</span><span class="ss"> rows × </span><span class="sc">{</span>pw<span class="sc">}</span><span class="ss"> columns = </span><span class="sc">{</span>ph <span class="op">*</span> pw<span class="sc">}</span><span class="ss"> total patches"</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the cropped dimensions (we may lose edge pixels)</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>Hc, Wc <span class="op">=</span> ph <span class="op">*</span> PATCH_SIZE, pw <span class="op">*</span> PATCH_SIZE</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Cropped image size: </span><span class="sc">{</span>Hc<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>Wc<span class="sc">}</span><span class="ss"> (original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Edge pixels lost: </span><span class="sc">{</span>H<span class="op">-</span>Hc<span class="sc">}</span><span class="ss"> height, </span><span class="sc">{</span>W<span class="op">-</span>Wc<span class="sc">}</span><span class="ss"> width"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Input image shape: 3 bands × 64 height × 64 width pixels
Using patch size: 64×64 pixels
Complete patches: 1 rows × 1 columns = 1 total patches
Cropped image size: 64×64 (original: 64×64)
Edge pixels lost: 0 height, 0 width</code></pre>
</div>
</div>
<div id="467c8398" class="cell" data-execution_count="11">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Crop the image to fit complete patches</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>arr_c <span class="op">=</span> arr_norm[:, :Hc, :Wc]</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Cropped array shape: </span><span class="sc">{</span>arr_c<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Visualize the grid overlay on the original image</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Show original image with patch grid overlay</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> C <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    rgb <span class="op">=</span> np.transpose(arr_norm[:<span class="dv">3</span>], (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>))</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    rgb <span class="op">=</span> np.stack([arr_norm[<span class="dv">0</span>]]<span class="op">*</span><span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>ax1.imshow(np.clip(rgb, <span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"Original Image with Patch Grid"</span>)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw grid lines to show patch boundaries</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ph <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    ax1.axhline(y<span class="op">=</span>i <span class="op">*</span> PATCH_SIZE <span class="op">-</span> <span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(pw <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    ax1.axvline(x<span class="op">=</span>j <span class="op">*</span> PATCH_SIZE <span class="op">-</span> <span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Show cropped version</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> C <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    rgb_cropped <span class="op">=</span> np.transpose(arr_c[:<span class="dv">3</span>], (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>))</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    rgb_cropped <span class="op">=</span> np.stack([arr_c[<span class="dv">0</span>]]<span class="op">*</span><span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>ax2.imshow(np.clip(rgb_cropped, <span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"Cropped Image (Complete Patches Only)"</span>)</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Cropped array shape: (3, 64, 64)</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="session1_data_foundations_original_files/figure-html/cell-12-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="37974cf7" class="cell" data-execution_count="12">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: The magical reshape operation that extracts patches</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co"># This is the core of patch extraction - let's break it down step by step</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"🔄 Patch extraction transformation:"</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"1. Input shape: </span><span class="sc">{</span>arr_c<span class="sc">.</span>shape<span class="sc">}</span><span class="ss"> → (bands, height, width)"</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Reshape to separate patch rows and columns</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>reshaped <span class="op">=</span> arr_c.reshape(C, ph, PATCH_SIZE, pw, PATCH_SIZE)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"2. After reshape: </span><span class="sc">{</span>reshaped<span class="sc">.</span>shape<span class="sc">}</span><span class="ss"> → (bands, patch_rows, patch_height, patch_cols, patch_width)"</span>)</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Transpose to group patches together</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>transposed <span class="op">=</span> reshaped.transpose(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"3. After transpose: </span><span class="sc">{</span>transposed<span class="sc">.</span>shape<span class="sc">}</span><span class="ss"> → (patch_rows, patch_cols, bands, patch_height, patch_width)"</span>)</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Final reshape to get individual patches</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>patches <span class="op">=</span> transposed.reshape(ph <span class="op">*</span> pw, C, PATCH_SIZE, PATCH_SIZE)</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"4. Final patches: </span><span class="sc">{</span>patches<span class="sc">.</span>shape<span class="sc">}</span><span class="ss"> → (num_patches, bands, patch_height, patch_width)"</span>)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">✅ Successfully extracted </span><span class="sc">{</span>patches<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> patches!"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>🔄 Patch extraction transformation:
1. Input shape: (3, 64, 64) → (bands, height, width)
2. After reshape: (3, 1, 64, 1, 64) → (bands, patch_rows, patch_height, patch_cols, patch_width)
3. After transpose: (1, 1, 3, 64, 64) → (patch_rows, patch_cols, bands, patch_height, patch_width)
4. Final patches: (1, 3, 64, 64) → (num_patches, bands, patch_height, patch_width)

✅ Successfully extracted 1 patches!</code></pre>
</div>
</div>
<div id="dcb65142" class="cell" data-execution_count="13">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Visualize sample patches to see what we've extracted</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>nshow <span class="op">=</span> <span class="bu">min</span>(<span class="dv">6</span>, <span class="bu">len</span>(patches))</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> axes.flatten()</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nshow):</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> patches[i]</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create RGB visualization (handle cases with fewer than 3 bands)</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> C <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>        rgb <span class="op">=</span> np.transpose(p[:<span class="dv">3</span>], (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>))</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>        rgb <span class="op">=</span> np.stack([p[<span class="dv">0</span>]]<span class="op">*</span><span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    axes[i].imshow(np.clip(rgb, <span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate patch position in the grid</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> i <span class="op">//</span> pw</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    col <span class="op">=</span> i <span class="op">%</span> pw</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    axes[i].set_title(<span class="ss">f"Patch </span><span class="sc">{</span>i<span class="sc">}</span><span class="ch">\n</span><span class="ss">Grid position: (</span><span class="sc">{</span>row<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    axes[i].axis(<span class="st">'off'</span>)</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Sample Patches: Our Image 'Tokens'"</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="session1_data_foundations_original_files/figure-html/cell-14-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="understanding-what-weve-created" class="level3">
<h3 class="anchored" data-anchor-id="understanding-what-weve-created">Understanding what we’ve created</h3>
<p>Each patch is now a self-contained “token” that represents a local region of our satellite image. Just like how words in a sentence carry meaning individually but also depend on context, these patches contain local spatial patterns while maintaining relationships to their neighboring patches.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Key Transformation
</div>
</div>
<div class="callout-body-container callout-body">
<p>We’ve transformed one large image <code>(3, H, W)</code> into <code>{ph × pw}</code> smaller images, each of shape <code>(3, 64, 64)</code>. This is exactly analogous to how tokenization transforms one long text into many smaller tokens that a model can process efficiently.</p>
</div>
</div>
<p>Why this matters: Patches become our fundamental unit of analysis—each patch can be processed independently while preserving spatial relationships for the model to learn landscape patterns.</p>
<hr>
</section>
</section>
<section id="assigning-patch-ids-metadata" class="level2">
<h2 class="anchored" data-anchor-id="assigning-patch-ids-metadata">1.4 Assigning patch IDs &amp; metadata 🏷️</h2>
<p><em>This section covers the metadata step in our roadmap: giving each patch an identity and spatial context.</em></p>
<p>“Every patch needs an identity — not just for bookkeeping, but to remember where and when it came from.”</p>
<ul>
<li>Generate unique IDs for patches.</li>
<li>Store spatial metadata (bounding box, CRS) and acquisition info.</li>
<li>Print one sample metadata record.</li>
</ul>
<div id="637496ff" class="cell" data-execution_count="14">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> rasterio.transform <span class="im">import</span> xy</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute patch bounding boxes (min lon/lat, max lon/lat approx)</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>ids <span class="op">=</span> []</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>meta <span class="op">=</span> []</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ph):</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(pw):</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        pid <span class="op">=</span> <span class="ss">f"patch_</span><span class="sc">{</span>i<span class="sc">:03d}</span><span class="ss">_</span><span class="sc">{</span>j<span class="sc">:03d}</span><span class="ss">"</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># top-left pixel (row=i*P, col=j*P)</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>        r0, c0 <span class="op">=</span> i<span class="op">*</span>PATCH_SIZE, j<span class="op">*</span>PATCH_SIZE</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        r1, c1 <span class="op">=</span> r0 <span class="op">+</span> PATCH_SIZE <span class="op">-</span> <span class="dv">1</span>, j <span class="op">*</span> PATCH_SIZE <span class="op">+</span> PATCH_SIZE <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>        (x0, y0) <span class="op">=</span> xy(transform, r0, c0)</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        (x1, y1) <span class="op">=</span> xy(transform, r1, c1)</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>        bbox <span class="op">=</span> (<span class="bu">min</span>(x0,x1), <span class="bu">min</span>(y0,y1), <span class="bu">max</span>(x0,x1), <span class="bu">max</span>(y0,y1))</span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>        ids.append(pid)</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>        meta.append({<span class="st">"id"</span>: pid, <span class="st">"bbox"</span>: bbox, <span class="st">"crs"</span>: <span class="bu">str</span>(crs)})</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"total ids:"</span>, <span class="bu">len</span>(ids))</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"sample record:"</span>, meta[<span class="dv">0</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>total ids: 1
sample record: {'id': 'patch_000_000', 'bbox': (280307.8749987148, 394531.1249900842, 280323.6249987148, 394546.8749900842), 'crs': 'PROJCS["Projection: Transverse Mercator; Datum: WGS84; Ellipsoid: WGS84",GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",19],PARAMETER["scale_factor",0.9993],PARAMETER["false_easting",500000],PARAMETER["false_northing",-5300000],UNIT["metre",1,AUTHORITY["EPSG","9001"]],AXIS["Easting",EAST],AXIS["Northing",NORTH]]'}</code></pre>
</div>
</div>
<p>Why this matters: metadata lets us track location/time and avoid leakage when splitting data.</p>
<hr>
</section>
<section id="adding-special-context-tokens-location-time-sensor" class="level2">
<h2 class="anchored" data-anchor-id="adding-special-context-tokens-location-time-sensor">1.5 Adding special context tokens (location, time, sensor) 🌍</h2>
<p><em>This section covers the spatial-temporal context step in our roadmap: encoding where and when each patch was captured.</em></p>
<p>“In addition to pixel values, our model benefits from knowing where and when the data was collected, and by which sensor.”</p>
<ul>
<li>Encode lat/lon as continuous features or sinusoidal embeddings.</li>
<li>Encode acquisition date as day‑of‑year + year.</li>
<li>Show how these features attach to patches.</li>
</ul>
<div id="f3701397" class="cell" data-execution_count="15">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> datetime <span class="im">as</span> dt</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Example acquisition date (placeholder metadata)</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>acq_date <span class="op">=</span> dt.date(<span class="dv">2023</span>, <span class="dv">7</span>, <span class="dv">15</span>)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>doy <span class="op">=</span> acq_date.timetuple().tm_yday</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> acq_date.year</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Use patch centers for location features</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>centers <span class="op">=</span> []</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ph):</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(pw):</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>        r, c <span class="op">=</span> i<span class="op">*</span>PATCH_SIZE <span class="op">+</span> PATCH_SIZE<span class="op">//</span><span class="dv">2</span>, j<span class="op">*</span>PATCH_SIZE <span class="op">+</span> PATCH_SIZE<span class="op">//</span><span class="dv">2</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>        x_c, y_c <span class="op">=</span> xy(transform, r, c)</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>        centers.append((x_c, y_c))</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>centers <span class="op">=</span> np.array(centers, dtype<span class="op">=</span>np.float32)</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple scaled features (you can swap for sinusoidal if desired)</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>loc_feat <span class="op">=</span> (centers <span class="op">-</span> centers.mean(<span class="dv">0</span>)) <span class="op">/</span> (centers.std(<span class="dv">0</span>) <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>time_feat <span class="op">=</span> np.array([doy<span class="op">/</span><span class="fl">366.0</span>, (year<span class="op">-</span><span class="dv">2000</span>)<span class="op">/</span><span class="fl">50.0</span>], dtype<span class="op">=</span>np.float32)  <span class="co"># scale to ~[0,1]</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"loc_feat shape:"</span>, loc_feat.shape, <span class="st">"time_feat:"</span>, time_feat.tolist())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>loc_feat shape: (1, 2) time_feat: [0.5355191230773926, 0.46000000834465027]</code></pre>
</div>
</div>
<p>Why this matters: models need context to learn spatial/temporal patterns.</p>
<hr>
</section>
<section id="dimensionality-reduction-for-spectral-bands-analogy-to-bpe" class="level2">
<h2 class="anchored" data-anchor-id="dimensionality-reduction-for-spectral-bands-analogy-to-bpe">1.6 Dimensionality reduction for spectral bands (analogy to BPE)</h2>
<p>“Sometimes we have more bands than the model needs. We can reduce the input size while keeping the most useful information.”</p>
<ul>
<li>Demonstrate PCA or band selection.</li>
<li>Compare original vs.&nbsp;reduced band profiles.</li>
</ul>
<div id="20446d93" class="cell" data-execution_count="16">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># PCA via SVD on (pixels, bands) for speed; sample a subset of pixels</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>C, Hc, Wc <span class="op">=</span> arr_c.shape</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>pixels <span class="op">=</span> arr_c.reshape(C, <span class="op">-</span><span class="dv">1</span>).T  <span class="co"># (N, C)</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> pixels.shape[<span class="dv">0</span>]</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>sub <span class="op">=</span> <span class="bu">min</span>(<span class="dv">5000</span>, N)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> np.random.default_rng(RNG_SEED).choice(N, sub, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>Xsub <span class="op">=</span> pixels[idx]</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Center</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> Xsub.mean(<span class="dv">0</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>Xc <span class="op">=</span> Xsub <span class="op">-</span> mu</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>U, S, Vt <span class="op">=</span> np.linalg.svd(Xc, full_matrices<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>explained <span class="op">=</span> (S<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> (S<span class="op">**</span><span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>keep <span class="op">=</span> <span class="bu">min</span>(<span class="dv">3</span>, C)</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>Wred <span class="op">=</span> Vt[:keep].T  <span class="co"># (C, keep)</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"bands:"</span>, C, <span class="st">"keep:"</span>, keep, <span class="st">"explained_var@keep:"</span>, <span class="bu">float</span>(explained[:keep].<span class="bu">sum</span>()))</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Project full image to reduced components per pixel</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>red_pixels <span class="op">=</span> (pixels <span class="op">-</span> mu).dot(Wred)  <span class="co"># (N, keep)</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>red_stack <span class="op">=</span> red_pixels.T.reshape(keep, Hc, Wc)</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"reduced stack shape:"</span>, red_stack.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>bands: 3 keep: 3 explained_var@keep: 1.0
reduced stack shape: (3, 64, 64)</code></pre>
</div>
</div>
<p>Why this matters: reducing input size speeds training and may denoise bands.</p>
<hr>
</section>
<section id="sampling-training-patches-sliding-windows-spatial-splits" class="level2">
<h2 class="anchored" data-anchor-id="sampling-training-patches-sliding-windows-spatial-splits">1.7 Sampling training patches (sliding windows, spatial splits)</h2>
<p>“Rather than using the whole dataset at once, we’ll sample patches in a way that keeps training efficient and avoids data leakage.”</p>
<ul>
<li>Show random vs.&nbsp;sliding‑window sampling.</li>
<li>Highlight spatial/temporal separation for validation/test.</li>
</ul>
<div id="5bbb5cf4" class="cell" data-execution_count="17">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>num_patches <span class="op">=</span> patches.shape[<span class="dv">0</span>]</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>all_idx <span class="op">=</span> np.arange(num_patches)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple spatial split by rows: top 80% train, bottom 20% val</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>rows <span class="op">=</span> np.repeat(np.arange(ph), pw)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>train_mask <span class="op">=</span> rows <span class="op">&lt;</span> <span class="bu">int</span>(<span class="fl">0.8</span><span class="op">*</span>ph)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>train_idx <span class="op">=</span> all_idx[train_mask]</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>val_idx <span class="op">=</span> all_idx[<span class="op">~</span>train_mask]</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(RNG_SEED)</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>rng.shuffle(train_idx)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"num_patches:"</span>, num_patches, <span class="st">"train:"</span>, <span class="bu">len</span>(train_idx), <span class="st">"val:"</span>, <span class="bu">len</span>(val_idx))</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"example train idx:"</span>, train_idx[:<span class="dv">8</span>].tolist())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>num_patches: 1 train: 0 val: 1
example train idx: []</code></pre>
</div>
</div>
<p>Why this matters: proper splits reduce spatial leakage and inflated metrics.</p>
<hr>
</section>
<section id="creating-patch-embeddings" class="level2">
<h2 class="anchored" data-anchor-id="creating-patch-embeddings">1.8 Creating patch embeddings 🧠</h2>
<p><em>This section covers the patch embeddings step in our roadmap: transforming spatial patches into the vector space where models operate.</em></p>
<p>“This is where pixels meet the model: we project each patch into an embedding space where the model can learn patterns.”</p>
<ul>
<li>Flatten + linear layer (minimal version).</li>
<li>Print embedding tensor shapes.</li>
<li>Show a few example embedding vectors.</li>
</ul>
<div id="7e561f87" class="cell" data-execution_count="18">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> torch</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    torch.manual_seed(RNG_SEED)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    B, C, P, _ <span class="op">=</span> patches.shape</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    input_dim <span class="op">=</span> C <span class="op">*</span> P <span class="op">*</span> P</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    embed_dim <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    proj <span class="op">=</span> torch.nn.Linear(input_dim, embed_dim)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># take a tiny batch of patches</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    sample <span class="op">=</span> torch.from_numpy(patches[:<span class="dv">4</span>]).reshape(<span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>).<span class="bu">float</span>()</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    emb <span class="op">=</span> proj(sample)</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"input_dim:"</span>, input_dim, <span class="st">"embed_dim:"</span>, embed_dim, <span class="st">"emb shape:"</span>, <span class="bu">tuple</span>(emb.shape))</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"first row (rounded):"</span>, [<span class="bu">float</span>(x) <span class="cf">for</span> x <span class="kw">in</span> emb[<span class="dv">0</span>][:<span class="dv">8</span>].detach().numpy().<span class="bu">round</span>(<span class="dv">3</span>)])</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Torch not available; skipping embeddings"</span>, e)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Torch not available; skipping embeddings mat1 and mat2 shapes cannot be multiplied (4x3072 and 12288x64)</code></pre>
</div>
</div>
<p>Why this matters: embeddings are the model’s operating space for learning patterns.</p>
<hr>
</section>
<section id="encoding-spatial-temporal-positions" class="level2">
<h2 class="anchored" data-anchor-id="encoding-spatial-temporal-positions">1.9 Encoding spatial &amp; temporal positions 📍</h2>
<p><em>This section covers the final step in our roadmap: adding positional encodings so models understand spatial and temporal relationships.</em></p>
<p>“Models don’t know where a patch sits in space or time unless we tell them — positional encodings add this crucial context.”</p>
<ul>
<li>Create 2D sinusoidal spatial encodings (row/col).</li>
<li>Add temporal encodings (day‑of‑year).</li>
<li>Combine with patch embeddings and inspect results.</li>
</ul>
<div id="b6eb45c2" class="cell" data-execution_count="19">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 2D sinusoidal positional encodings for (row, col)</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>rows_grid <span class="op">=</span> np.arange(ph)[:,<span class="va">None</span>].repeat(pw,<span class="dv">1</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>cols_grid <span class="op">=</span> np.arange(pw)[<span class="va">None</span>,:].repeat(ph,<span class="dv">0</span>)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>pos2d <span class="op">=</span> np.stack([rows_grid.ravel(), cols_grid.ravel()], axis<span class="op">=</span><span class="dv">1</span>).astype(np.float32)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Scale rows/cols to [0,1]</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>pos2d <span class="op">=</span> (pos2d <span class="op">-</span> pos2d.<span class="bu">min</span>(<span class="dv">0</span>)) <span class="op">/</span> (pos2d.ptp(<span class="dv">0</span>) <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple sin/cos features</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>pos_feat <span class="op">=</span> np.concatenate([np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>pos2d), np.cos(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>pos2d)], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="co"># time features from earlier (same for all patches here)</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>time_feat_full <span class="op">=</span> np.repeat(time_feat[<span class="va">None</span>,:], <span class="bu">len</span>(pos_feat), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"pos_feat shape:"</span>, pos_feat.shape, <span class="st">"time_feat_full shape:"</span>, time_feat_full.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>pos_feat shape: (1, 4) time_feat_full shape: (1, 2)</code></pre>
</div>
</div>
<div id="02f351a2" class="cell" data-execution_count="20">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine: embedding + positional + time features (toy example)</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    comb <span class="op">=</span> np.concatenate([</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>        emb.detach().numpy(),         <span class="co"># (4, 64) toy batch</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>        pos_feat[:<span class="dv">4</span>],                 <span class="co"># (4, 4)</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>        time_feat_full[:<span class="dv">4</span>]            <span class="co"># (4, 2)</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    ], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"combined features shape:"</span>, comb.shape)</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Combine skipped:"</span>, e)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Combine skipped: name 'emb' is not defined</code></pre>
</div>
</div>
<p>Why this matters: spatial/temporal encodings provide essential context alongside pixel content.</p>
<hr>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<ul>
<li>We inspected raster metadata (CRS, resolution, bands) and normalized bands</li>
<li>We extracted fixed‑size patches, attached IDs/metadata, and added location/time features</li>
<li>We created minimal patch embeddings and combined them with positional/temporal encodings</li>
</ul>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<ul>
<li>Quarto: https://quarto.org/docs</li>
<li>Rasterio: https://rasterio.readthedocs.io/</li>
<li>NumPy: https://numpy.org/doc/</li>
<li>PyTorch: https://pytorch.org/docs/stable/index.html</li>
<li>Vision Transformers (ViT): https://arxiv.org/abs/2010.11929</li>
</ul>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb41" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Working with Geospatial Raster Data"</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "From raw rasters to model‑ready embeddings, step by step"</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="an">editor_options:</span><span class="co"> </span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co">  chunk_output_type: console</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> geoai</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span><span class="co"> </span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="co">    html:</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a><span class="co">        toc: true</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="co">        toc-depth: 2</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a><span class="co">        code-fold: show</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>In this session, we learn how to transform raw geospatial raster data into model‑ready embeddings. We’ll work with a tiny multi‑band GeoTIFF, build small, deterministic processing steps, and show visible outputs after every step. The goal is to build intuition that mirrors LLM pipelines (tokenization → embeddings) while grounding everything in images (patches → embeddings).</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a><span class="fu">## Learning Objectives</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Load and inspect small multi‑band rasters (CRS, resolution, dtype, bands)</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Normalize and organize bands for consistent modeling</span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Extract fixed‑size patches</span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Add contextual features (location/time “tokens”)</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Sample training patches correctly and create patch embeddings with shapes you can verify</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a><span class="fu">## Session Roadmap</span></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>This session follows a complete data processing pipeline organized into three logical phases that transform raw satellite imagery into model-ready embeddings:</span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a><span class="in">```{mermaid}</span></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a><span class="in">flowchart TD</span></span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph Phase1 ["🔬 Phase 1: Pixel-Level Pre-processing"]</span></span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a><span class="in">        direction LR</span></span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a><span class="in">        A["🛰️ Raw Data&lt;br/&gt;Inspection&lt;br/&gt;Section 1.1"] --&gt; B["📐 Band&lt;br/&gt;Normalization&lt;br/&gt;Section 1.2"]</span></span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a><span class="in">        B --&gt; C["🔬 Dimensionality&lt;br/&gt;Reduction&lt;br/&gt;Section 1.3"]</span></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph Phase2 ["🗺️ Phase 2: Spatial-Structure Processing"]</span></span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a><span class="in">        direction LR</span></span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a><span class="in">        D["✂️ Patch&lt;br/&gt;Extraction&lt;br/&gt;Section 2.1"] --&gt; E["🏷️ Patch&lt;br/&gt;Metadata&lt;br/&gt;Section 2.2"]</span></span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a><span class="in">        E --&gt; F["🌍 Spatial-Temporal&lt;br/&gt;Context&lt;br/&gt;Section 2.3"]</span></span>
<span id="cb41-43"><a href="#cb41-43" aria-hidden="true" tabindex="-1"></a><span class="in">        F --&gt; G["📊 Training&lt;br/&gt;Sampling&lt;br/&gt;Section 2.4"]</span></span>
<span id="cb41-44"><a href="#cb41-44" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb41-45"><a href="#cb41-45" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb41-46"><a href="#cb41-46" aria-hidden="true" tabindex="-1"></a><span class="in">    subgraph Phase3 ["🧠 Phase 3: Model-Ready Processing"]</span></span>
<span id="cb41-47"><a href="#cb41-47" aria-hidden="true" tabindex="-1"></a><span class="in">        direction LR</span></span>
<span id="cb41-48"><a href="#cb41-48" aria-hidden="true" tabindex="-1"></a><span class="in">        H["🧠 Patch&lt;br/&gt;Embeddings&lt;br/&gt;Section 3.1"] --&gt; I["📍 Positional&lt;br/&gt;Encoding&lt;br/&gt;Section 3.2"]</span></span>
<span id="cb41-49"><a href="#cb41-49" aria-hidden="true" tabindex="-1"></a><span class="in">    end</span></span>
<span id="cb41-50"><a href="#cb41-50" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb41-51"><a href="#cb41-51" aria-hidden="true" tabindex="-1"></a><span class="in">    Phase1 --&gt; Phase2</span></span>
<span id="cb41-52"><a href="#cb41-52" aria-hidden="true" tabindex="-1"></a><span class="in">    Phase2 --&gt; Phase3</span></span>
<span id="cb41-53"><a href="#cb41-53" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb41-54"><a href="#cb41-54" aria-hidden="true" tabindex="-1"></a><span class="in">    style Phase1 fill:#e3f2fd</span></span>
<span id="cb41-55"><a href="#cb41-55" aria-hidden="true" tabindex="-1"></a><span class="in">    style Phase2 fill:#fff3e0  </span></span>
<span id="cb41-56"><a href="#cb41-56" aria-hidden="true" tabindex="-1"></a><span class="in">    style Phase3 fill:#e8f5e8</span></span>
<span id="cb41-57"><a href="#cb41-57" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-58"><a href="#cb41-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-59"><a href="#cb41-59" aria-hidden="true" tabindex="-1"></a><span class="fu">## Setting Up</span></span>
<span id="cb41-60"><a href="#cb41-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-61"><a href="#cb41-61" aria-hidden="true" tabindex="-1"></a>Before we get started, let's setup our computational environment by loading necessary libraries and seeding our computations.</span>
<span id="cb41-62"><a href="#cb41-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-63"><a href="#cb41-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-64"><a href="#cb41-64" aria-hidden="true" tabindex="-1"></a><span class="fu">### Load required libraries</span></span>
<span id="cb41-65"><a href="#cb41-65" aria-hidden="true" tabindex="-1"></a>Why these imports: file paths (Path), randomness (random, numpy), and plotting (matplotlib) are used throughout the session.</span>
<span id="cb41-66"><a href="#cb41-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-69"><a href="#cb41-69" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-70"><a href="#cb41-70" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-71"><a href="#cb41-71" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os, random</span>
<span id="cb41-72"><a href="#cb41-72" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb41-73"><a href="#cb41-73" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb41-74"><a href="#cb41-74" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb41-75"><a href="#cb41-75" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Imports OK"</span>)</span>
<span id="cb41-76"><a href="#cb41-76" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-77"><a href="#cb41-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-78"><a href="#cb41-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-79"><a href="#cb41-79" aria-hidden="true" tabindex="-1"></a><span class="fu">### Set Random Number Generation (RNG) seeds</span></span>
<span id="cb41-80"><a href="#cb41-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-81"><a href="#cb41-81" aria-hidden="true" tabindex="-1"></a>We use fixed seeds to ensure that our randomness is consistent every time we run our example code. This allows your results to match the rendered output on the course site.</span>
<span id="cb41-82"><a href="#cb41-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-85"><a href="#cb41-85" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-86"><a href="#cb41-86" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-87"><a href="#cb41-87" aria-hidden="true" tabindex="-1"></a>RNG_SEED <span class="op">=</span> <span class="dv">42</span></span>
<span id="cb41-88"><a href="#cb41-88" aria-hidden="true" tabindex="-1"></a>os.environ[<span class="st">"PYTHONHASHSEED"</span>] <span class="op">=</span> <span class="bu">str</span>(RNG_SEED)</span>
<span id="cb41-89"><a href="#cb41-89" aria-hidden="true" tabindex="-1"></a>random.seed(RNG_SEED)</span>
<span id="cb41-90"><a href="#cb41-90" aria-hidden="true" tabindex="-1"></a>np.random.seed(RNG_SEED)</span>
<span id="cb41-91"><a href="#cb41-91" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Seeds set:"</span>, RNG_SEED)</span>
<span id="cb41-92"><a href="#cb41-92" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-93"><a href="#cb41-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-94"><a href="#cb41-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-95"><a href="#cb41-95" aria-hidden="true" tabindex="-1"></a><span class="fu">### Define data paths and constants</span></span>
<span id="cb41-96"><a href="#cb41-96" aria-hidden="true" tabindex="-1"></a>We’ll store the sample raster in a local <span class="in">`data/`</span> directory and set a default patch size.</span>
<span id="cb41-97"><a href="#cb41-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-100"><a href="#cb41-100" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-101"><a href="#cb41-101" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-102"><a href="#cb41-102" aria-hidden="true" tabindex="-1"></a><span class="co"># Use absolute path to ensure we find the data file</span></span>
<span id="cb41-103"><a href="#cb41-103" aria-hidden="true" tabindex="-1"></a>DATA_DIR <span class="op">=</span> Path(<span class="va">__file__</span>).parent.parent.parent.parent <span class="op">/</span> <span class="st">"data"</span> <span class="cf">if</span> <span class="st">"__file__"</span> <span class="kw">in</span> <span class="bu">globals</span>() <span class="cf">else</span> Path(<span class="st">"../../../data"</span>)</span>
<span id="cb41-104"><a href="#cb41-104" aria-hidden="true" tabindex="-1"></a>DATA_DIR.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb41-105"><a href="#cb41-105" aria-hidden="true" tabindex="-1"></a>DATA_PATH <span class="op">=</span> DATA_DIR <span class="op">/</span> <span class="st">"landcover_sample.tif"</span></span>
<span id="cb41-106"><a href="#cb41-106" aria-hidden="true" tabindex="-1"></a>PATCH_SIZE <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb41-107"><a href="#cb41-107" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"DATA_PATH:"</span>, DATA_PATH)</span>
<span id="cb41-108"><a href="#cb41-108" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"DATA_PATH exists:"</span>, DATA_PATH.exists())</span>
<span id="cb41-109"><a href="#cb41-109" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Current working directory:"</span>, Path.cwd())</span>
<span id="cb41-110"><a href="#cb41-110" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"PATCH_SIZE:"</span>, PATCH_SIZE)</span>
<span id="cb41-111"><a href="#cb41-111" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-112"><a href="#cb41-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-113"><a href="#cb41-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-114"><a href="#cb41-114" aria-hidden="true" tabindex="-1"></a>If the file is missing, we’ll download a small sample.</span>
<span id="cb41-115"><a href="#cb41-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-118"><a href="#cb41-118" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-119"><a href="#cb41-119" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-120"><a href="#cb41-120" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> DATA_PATH.exists():</span>
<span id="cb41-121"><a href="#cb41-121" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="pp">FileNotFoundError</span>(<span class="ss">f"Data file not found at </span><span class="sc">{</span>DATA_PATH<span class="sc">}</span><span class="ss">. Please ensure the landcover_sample.tif file is available in the data directory."</span>)</span>
<span id="cb41-122"><a href="#cb41-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-123"><a href="#cb41-123" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"✓ Data file found!"</span>)</span>
<span id="cb41-124"><a href="#cb41-124" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Path: </span><span class="sc">{</span>DATA_PATH<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb41-125"><a href="#cb41-125" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Size (KB): </span><span class="sc">{</span><span class="bu">round</span>(DATA_PATH.stat().st_size<span class="op">/</span><span class="dv">1024</span>,<span class="dv">1</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb41-126"><a href="#cb41-126" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-127"><a href="#cb41-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-128"><a href="#cb41-128" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb41-129"><a href="#cb41-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-130"><a href="#cb41-130" aria-hidden="true" tabindex="-1"></a><span class="fu"># 🔬 Phase 1: Pixel-Level Pre-processing</span></span>
<span id="cb41-131"><a href="#cb41-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-132"><a href="#cb41-132" aria-hidden="true" tabindex="-1"></a>*In this phase, we work with the full image and operate on individual pixels. We'll develop code to read our raw data, normalize it for consistent model training, and perform dimensionality reduction before moving to spatial operations.*</span>
<span id="cb41-133"><a href="#cb41-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-134"><a href="#cb41-134" aria-hidden="true" tabindex="-1"></a><span class="fu">## 1.1 🛰️ Raw Data Inspection</span></span>
<span id="cb41-135"><a href="#cb41-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-136"><a href="#cb41-136" aria-hidden="true" tabindex="-1"></a><span class="fu">### Reading Geospatial Data</span></span>
<span id="cb41-137"><a href="#cb41-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-138"><a href="#cb41-138" aria-hidden="true" tabindex="-1"></a>Before we start working with the data in Python, it’s important to understand what kinds of information a geospatial raster dataset contains.</span>
<span id="cb41-139"><a href="#cb41-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-140"><a href="#cb41-140" aria-hidden="true" tabindex="-1"></a>A single raster file stores **two broad categories of information**:</span>
<span id="cb41-141"><a href="#cb41-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-142"><a href="#cb41-142" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Pixel values** – the actual measurements.  </span>
<span id="cb41-143"><a href="#cb41-143" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Each pixel has one or more **bands** (channels) that store numeric values.  </span>
<span id="cb41-144"><a href="#cb41-144" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Bands might represent reflectance in different wavelengths, elevation, temperature, or derived indices like NDVI.  </span>
<span id="cb41-145"><a href="#cb41-145" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Pixel values are stored in a numeric data type (e.g., integers or floats) and have a defined range (min/max).</span>
<span id="cb41-146"><a href="#cb41-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-147"><a href="#cb41-147" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Spatial metadata** – information that describes where and how those measurements fit on Earth.  </span>
<span id="cb41-148"><a href="#cb41-148" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Location reference** — how pixel positions map to real-world coordinates.  </span>
<span id="cb41-149"><a href="#cb41-149" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Pixel resolution** — the width and height of each pixel in ground units (e.g., meters).  </span>
<span id="cb41-150"><a href="#cb41-150" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Grid layout and orientation** — how rows and columns are aligned in space.  </span>
<span id="cb41-151"><a href="#cb41-151" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Coordinate system** — the mathematical model that defines positions on Earth (projection).  </span>
<span id="cb41-152"><a href="#cb41-152" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>**Transform** — a mapping from pixel coordinates (row/col) to real-world coordinates (x/y).</span>
<span id="cb41-153"><a href="#cb41-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-154"><a href="#cb41-154" aria-hidden="true" tabindex="-1"></a>When we open a raster with <span class="in">`rasterio`</span>, we can access **both** the measurement values and the spatial metadata.  This lets us work with the data not just as an image, but as a set of geographically-anchored measurements we can relate to location, time, and other datasets. Let's take a look at our sample image. </span>
<span id="cb41-155"><a href="#cb41-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-156"><a href="#cb41-156" aria-hidden="true" tabindex="-1"></a><span class="fu">### Rasterio image reading and metadata inspection</span></span>
<span id="cb41-157"><a href="#cb41-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-160"><a href="#cb41-160" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-161"><a href="#cb41-161" aria-hidden="true" tabindex="-1"></a><span class="co"># | echo: true</span></span>
<span id="cb41-162"><a href="#cb41-162" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> rasterio <span class="im">as</span> rio</span>
<span id="cb41-163"><a href="#cb41-163" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyproj</span>
<span id="cb41-164"><a href="#cb41-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-165"><a href="#cb41-165" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> rio.<span class="bu">open</span>(DATA_PATH) <span class="im">as</span> src:</span>
<span id="cb41-166"><a href="#cb41-166" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> src.read()                          <span class="co"># (bands, height, width)</span></span>
<span id="cb41-167"><a href="#cb41-167" aria-hidden="true" tabindex="-1"></a>    band_count, height, width <span class="op">=</span> arr.shape</span>
<span id="cb41-168"><a href="#cb41-168" aria-hidden="true" tabindex="-1"></a>    dtype <span class="op">=</span> arr.dtype</span>
<span id="cb41-169"><a href="#cb41-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-170"><a href="#cb41-170" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CRS and EPSG</span></span>
<span id="cb41-171"><a href="#cb41-171" aria-hidden="true" tabindex="-1"></a>    crs <span class="op">=</span> src.crs</span>
<span id="cb41-172"><a href="#cb41-172" aria-hidden="true" tabindex="-1"></a>    epsg <span class="op">=</span> crs.to_epsg()</span>
<span id="cb41-173"><a href="#cb41-173" aria-hidden="true" tabindex="-1"></a>    transform <span class="op">=</span> src.transform  <span class="co"># Save transform for later use</span></span>
<span id="cb41-174"><a href="#cb41-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-175"><a href="#cb41-175" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get a human-readable CRS name</span></span>
<span id="cb41-176"><a href="#cb41-176" aria-hidden="true" tabindex="-1"></a>    crs_info <span class="op">=</span> pyproj.CRS.from_user_input(crs)</span>
<span id="cb41-177"><a href="#cb41-177" aria-hidden="true" tabindex="-1"></a>    crs_name <span class="op">=</span> crs_info.name</span>
<span id="cb41-178"><a href="#cb41-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-179"><a href="#cb41-179" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Resolution in CRS units</span></span>
<span id="cb41-180"><a href="#cb41-180" aria-hidden="true" tabindex="-1"></a>    res_x, res_y <span class="op">=</span> src.res</span>
<span id="cb41-181"><a href="#cb41-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-182"><a href="#cb41-182" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Print summary ---</span></span>
<span id="cb41-183"><a href="#cb41-183" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Shape: </span><span class="sc">{</span>arr<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb41-184"><a href="#cb41-184" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Bands: </span><span class="sc">{</span>band_count<span class="sc">}</span><span class="ss">  |  Height: </span><span class="sc">{</span>height<span class="sc">}</span><span class="ss"> px  Width: </span><span class="sc">{</span>width<span class="sc">}</span><span class="ss"> px |  Data type: </span><span class="sc">{</span>dtype<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb41-185"><a href="#cb41-185" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"CRS: </span><span class="sc">{</span>crs_name<span class="sc">}</span><span class="ss">"</span> <span class="op">+</span> (<span class="ss">f" (EPSG:</span><span class="sc">{</span>epsg<span class="sc">}</span><span class="ss">)"</span> <span class="cf">if</span> epsg <span class="cf">else</span> <span class="st">""</span>))</span>
<span id="cb41-186"><a href="#cb41-186" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Resolution: </span><span class="sc">{</span>res_x<span class="sc">:.2f}</span><span class="ss"> × </span><span class="sc">{</span>res_y<span class="sc">:.2f}</span><span class="ss"> ground units per pixel"</span>)</span>
<span id="cb41-187"><a href="#cb41-187" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Per-band min/max:"</span>)</span>
<span id="cb41-188"><a href="#cb41-188" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, b <span class="kw">in</span> <span class="bu">enumerate</span>(arr, start<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb41-189"><a href="#cb41-189" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Band </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span><span class="bu">float</span>(b.<span class="bu">min</span>())<span class="sc">:.3f}</span><span class="ss"> – </span><span class="sc">{</span><span class="bu">float</span>(b.<span class="bu">max</span>())<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb41-190"><a href="#cb41-190" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-191"><a href="#cb41-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-192"><a href="#cb41-192" aria-hidden="true" tabindex="-1"></a>Notice how the output gives us the fundamental "identity" of our geospatial data. The <span class="in">`arr.shape`</span> tells us we have a 3D array(bands × height × width), the Coordinate Reference System (CRS) anchors this data to a specific location on Earth, and the resolution information tells us the real-world size of each pixel. Finally, the per-band min/max values reveal the dynamic range of our spectral measurements. </span>
<span id="cb41-193"><a href="#cb41-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-194"><a href="#cb41-194" aria-hidden="true" tabindex="-1"></a>Although the pixel values in this image are stored as <span class="in">`uint8`</span>, which supports a range from 0 to 255, all three bands in our dataset have maximum values of <span class="in">`254`</span>. This usually happens because the largest possible value in the data type is often reserved as a <span class="in">`NoData`</span> flag, marking pixels with no valid measurement. This upper limit is specific to this dataset, and the use of <span class="in">`NoData`</span> flags is dataset dependent.</span>
<span id="cb41-195"><a href="#cb41-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-196"><a href="#cb41-196" aria-hidden="true" tabindex="-1"></a>Image metadata is crucial because satellite imagery comes with precise spatial and spectral calibration. Each pixel value either represents actual physical measurements (like surface reflectance) at a specific geographic location, or a specific category that maps to a classification based on the dataset. Our model needs to understand not just "what values doe this pixel contain?" but also "where is this pixel?" and "what does this pixel represent?"</span>
<span id="cb41-197"><a href="#cb41-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-198"><a href="#cb41-198" aria-hidden="true" tabindex="-1"></a>:::{.callout-note}</span>
<span id="cb41-199"><a href="#cb41-199" aria-hidden="true" tabindex="-1"></a><span class="fu">## Digital Numbers</span></span>
<span id="cb41-200"><a href="#cb41-200" aria-hidden="true" tabindex="-1"></a>The raw pixel values in many geospatial images are stored as integers to reduce file size and improve processing speed.  These integer values are called **Digital Numbers** (<span class="in">`DN`</span>s).  </span>
<span id="cb41-201"><a href="#cb41-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-202"><a href="#cb41-202" aria-hidden="true" tabindex="-1"></a>A <span class="in">`DN`</span> is an instrument-recorded value that may need to be scaled or converted to physical units (such as reflectance or temperature) before analysis.</span>
<span id="cb41-203"><a href="#cb41-203" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb41-204"><a href="#cb41-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-205"><a href="#cb41-205" aria-hidden="true" tabindex="-1"></a><span class="fu">### DN visualization</span></span>
<span id="cb41-206"><a href="#cb41-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-209"><a href="#cb41-209" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-210"><a href="#cb41-210" aria-hidden="true" tabindex="-1"></a><span class="co"># | echo: true</span></span>
<span id="cb41-211"><a href="#cb41-211" aria-hidden="true" tabindex="-1"></a><span class="co"># | code-fold: true</span></span>
<span id="cb41-212"><a href="#cb41-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-213"><a href="#cb41-213" aria-hidden="true" tabindex="-1"></a><span class="co"># Display each band's raw DNs</span></span>
<span id="cb41-214"><a href="#cb41-214" aria-hidden="true" tabindex="-1"></a>num_bands <span class="op">=</span> arr.shape[<span class="dv">0</span>]</span>
<span id="cb41-215"><a href="#cb41-215" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, num_bands, figsize<span class="op">=</span>(<span class="dv">4</span><span class="op">*</span>num_bands, <span class="dv">4</span>))</span>
<span id="cb41-216"><a href="#cb41-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-217"><a href="#cb41-217" aria-hidden="true" tabindex="-1"></a><span class="co"># Handle case where we only have one band</span></span>
<span id="cb41-218"><a href="#cb41-218" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> num_bands <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb41-219"><a href="#cb41-219" aria-hidden="true" tabindex="-1"></a>    axes <span class="op">=</span> [axes]</span>
<span id="cb41-220"><a href="#cb41-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-221"><a href="#cb41-221" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_bands):</span>
<span id="cb41-222"><a href="#cb41-222" aria-hidden="true" tabindex="-1"></a>    band <span class="op">=</span> arr[i]</span>
<span id="cb41-223"><a href="#cb41-223" aria-hidden="true" tabindex="-1"></a>    data_min, data_max <span class="op">=</span> <span class="bu">float</span>(band.<span class="bu">min</span>()), <span class="bu">float</span>(band.<span class="bu">max</span>())</span>
<span id="cb41-224"><a href="#cb41-224" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-225"><a href="#cb41-225" aria-hidden="true" tabindex="-1"></a>    im <span class="op">=</span> axes[i].imshow(band, cmap<span class="op">=</span><span class="st">'viridis'</span>, vmin<span class="op">=</span>data_min, vmax<span class="op">=</span>data_max)</span>
<span id="cb41-226"><a href="#cb41-226" aria-hidden="true" tabindex="-1"></a>    axes[i].set_title(<span class="ss">f"Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Raw Values</span><span class="ch">\n</span><span class="ss">(Range: </span><span class="sc">{</span>data_min<span class="sc">:.0f}</span><span class="ss"> - </span><span class="sc">{</span>data_max<span class="sc">:.0f}</span><span class="ss">)"</span>)</span>
<span id="cb41-227"><a href="#cb41-227" aria-hidden="true" tabindex="-1"></a>    axes[i].axis(<span class="st">'off'</span>)</span>
<span id="cb41-228"><a href="#cb41-228" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-229"><a href="#cb41-229" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add colorbar for each band</span></span>
<span id="cb41-230"><a href="#cb41-230" aria-hidden="true" tabindex="-1"></a>    plt.colorbar(im, ax<span class="op">=</span>axes[i], label<span class="op">=</span><span class="st">'Digital Number (DN)'</span>, shrink<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb41-231"><a href="#cb41-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-232"><a href="#cb41-232" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb41-233"><a href="#cb41-233" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb41-234"><a href="#cb41-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-235"><a href="#cb41-235" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-236"><a href="#cb41-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-237"><a href="#cb41-237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-238"><a href="#cb41-238" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb41-239"><a href="#cb41-239" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-240"><a href="#cb41-240" aria-hidden="true" tabindex="-1"></a><span class="fu">## 1.2  📐 Band Normalization</span></span>
<span id="cb41-241"><a href="#cb41-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-242"><a href="#cb41-242" aria-hidden="true" tabindex="-1"></a>*Scaling bands to consistent ranges for stable model training*</span>
<span id="cb41-243"><a href="#cb41-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-244"><a href="#cb41-244" aria-hidden="true" tabindex="-1"></a>Now that we've examined our raw data, we need to prepare it for neural network processing. While the raw digital numbers are meaningful for interpretation, they present several challenges when used directly as input to models. Different spectral bands often have vastly different value ranges, and **neural networks are sensitive to the scale of input features**.</span>
<span id="cb41-245"><a href="#cb41-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-246"><a href="#cb41-246" aria-hidden="true" tabindex="-1"></a><span class="fu">### Why normalize geospatial data?</span></span>
<span id="cb41-247"><a href="#cb41-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-248"><a href="#cb41-248" aria-hidden="true" tabindex="-1"></a>Normalization serves several critical purposes in geospatial machine learning:</span>
<span id="cb41-249"><a href="#cb41-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-250"><a href="#cb41-250" aria-hidden="true" tabindex="-1"></a>**Scale Invariance**: Different spectral bands capture different physical phenomena and often have dramatically different value ranges. For example, near-infrared reflectance might range from 0-4000 DN, while visible bands range from 0-255 DN. Without normalization, the model would be dominated by the larger-valued bands.</span>
<span id="cb41-251"><a href="#cb41-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-252"><a href="#cb41-252" aria-hidden="true" tabindex="-1"></a>**Training Stability**: Neural networks use gradient-based optimization, which works best when input features have similar scales. Large differences in feature magnitude can cause unstable gradients, slow convergence, or poor performance.</span>
<span id="cb41-253"><a href="#cb41-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-254"><a href="#cb41-254" aria-hidden="true" tabindex="-1"></a>**Sensor Consistency**: When working with data from multiple sensors or time periods, normalization helps remove acquisition-specific biases while preserving the relative patterns that matter for learning.</span>
<span id="cb41-255"><a href="#cb41-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-256"><a href="#cb41-256" aria-hidden="true" tabindex="-1"></a>**Activation Function Compatibility**: Many neural network activation functions (like <span class="in">`sigmoid`</span> or <span class="in">`tanh`</span>) work optimally when inputs are in specific ranges. Normalized inputs help ensure we're operating in the most effective part of these functions.</span>
<span id="cb41-257"><a href="#cb41-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-258"><a href="#cb41-258" aria-hidden="true" tabindex="-1"></a><span class="fu">### Common normalization approaches</span></span>
<span id="cb41-259"><a href="#cb41-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-260"><a href="#cb41-260" aria-hidden="true" tabindex="-1"></a>Let's examine the most common normalization strategies for geospatial data:</span>
<span id="cb41-261"><a href="#cb41-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-262"><a href="#cb41-262" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Min-Max Normalization (what we'll use)</span></span>
<span id="cb41-263"><a href="#cb41-263" aria-hidden="true" tabindex="-1"></a>Scales each band to a fixed range, typically <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>:</span>
<span id="cb41-264"><a href="#cb41-264" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-265"><a href="#cb41-265" aria-hidden="true" tabindex="-1"></a><span class="in">normalized = (value - min) / (max - min)</span></span>
<span id="cb41-266"><a href="#cb41-266" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-267"><a href="#cb41-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-268"><a href="#cb41-268" aria-hidden="true" tabindex="-1"></a>**Pros**: Preserves the distribution shape, guarantees output range  </span>
<span id="cb41-269"><a href="#cb41-269" aria-hidden="true" tabindex="-1"></a>**Cons**: Sensitive to outliers, range depends on specific dataset</span>
<span id="cb41-270"><a href="#cb41-270" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-271"><a href="#cb41-271" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Z-Score Standardization  </span></span>
<span id="cb41-272"><a href="#cb41-272" aria-hidden="true" tabindex="-1"></a>Centers data around zero with unit variance:</span>
<span id="cb41-273"><a href="#cb41-273" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-274"><a href="#cb41-274" aria-hidden="true" tabindex="-1"></a><span class="in">standardized = (value - mean) / std</span></span>
<span id="cb41-275"><a href="#cb41-275" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-276"><a href="#cb41-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-277"><a href="#cb41-277" aria-hidden="true" tabindex="-1"></a>**Pros**: Removes mean/variance effects, handles outliers better  </span>
<span id="cb41-278"><a href="#cb41-278" aria-hidden="true" tabindex="-1"></a>**Cons**: Output range is unbounded, can lose interpretability</span>
<span id="cb41-279"><a href="#cb41-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-280"><a href="#cb41-280" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Robust Scaling</span></span>
<span id="cb41-281"><a href="#cb41-281" aria-hidden="true" tabindex="-1"></a>Uses median and interquartile range instead of mean/std:</span>
<span id="cb41-282"><a href="#cb41-282" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-283"><a href="#cb41-283" aria-hidden="true" tabindex="-1"></a><span class="in">robust = (value - median) / (75th_percentile - 25th_percentile)</span></span>
<span id="cb41-284"><a href="#cb41-284" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-285"><a href="#cb41-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-286"><a href="#cb41-286" aria-hidden="true" tabindex="-1"></a>**Pros**: Very robust to outliers  </span>
<span id="cb41-287"><a href="#cb41-287" aria-hidden="true" tabindex="-1"></a>**Cons**: More complex, can compress dynamic range</span>
<span id="cb41-288"><a href="#cb41-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-289"><a href="#cb41-289" aria-hidden="true" tabindex="-1"></a>For this exercise, we'll use min-max normalization because it's intuitive and preserves the relative structure of our data while ensuring all bands contribute equally to the model.</span>
<span id="cb41-290"><a href="#cb41-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-291"><a href="#cb41-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-292"><a href="#cb41-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-295"><a href="#cb41-295" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-296"><a href="#cb41-296" aria-hidden="true" tabindex="-1"></a><span class="co"># | echo: true</span></span>
<span id="cb41-297"><a href="#cb41-297" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert to float32 for numerical precision in calculations</span></span>
<span id="cb41-298"><a href="#cb41-298" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> arr.astype(np.float32)</span>
<span id="cb41-299"><a href="#cb41-299" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Data type after conversion: </span><span class="sc">{</span>arr<span class="sc">.</span>dtype<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb41-300"><a href="#cb41-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-301"><a href="#cb41-301" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate per-band statistics</span></span>
<span id="cb41-302"><a href="#cb41-302" aria-hidden="true" tabindex="-1"></a><span class="co"># Reshape to (bands, pixels) for easier computation</span></span>
<span id="cb41-303"><a href="#cb41-303" aria-hidden="true" tabindex="-1"></a>pixel_values <span class="op">=</span> arr.reshape(arr.shape[<span class="dv">0</span>], <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb41-304"><a href="#cb41-304" aria-hidden="true" tabindex="-1"></a>mins <span class="op">=</span> pixel_values.<span class="bu">min</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb41-305"><a href="#cb41-305" aria-hidden="true" tabindex="-1"></a>maxs <span class="op">=</span> pixel_values.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb41-306"><a href="#cb41-306" aria-hidden="true" tabindex="-1"></a>ranges <span class="op">=</span> maxs <span class="op">-</span> mins</span>
<span id="cb41-307"><a href="#cb41-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-308"><a href="#cb41-308" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Per-band statistics before normalization:"</span>)</span>
<span id="cb41-309"><a href="#cb41-309" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(mins)):</span>
<span id="cb41-310"><a href="#cb41-310" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: min=</span><span class="sc">{</span>mins[i]<span class="sc">:.1f}</span><span class="ss">, max=</span><span class="sc">{</span>maxs[i]<span class="sc">:.1f}</span><span class="ss">, range=</span><span class="sc">{</span>ranges[i]<span class="sc">:.1f}</span><span class="ss">"</span>)</span>
<span id="cb41-311"><a href="#cb41-311" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-312"><a href="#cb41-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-315"><a href="#cb41-315" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-316"><a href="#cb41-316" aria-hidden="true" tabindex="-1"></a><span class="co"># | echo: true</span></span>
<span id="cb41-317"><a href="#cb41-317" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply min-max normalization: (x - min) / (max - min)</span></span>
<span id="cb41-318"><a href="#cb41-318" aria-hidden="true" tabindex="-1"></a><span class="co"># Add small epsilon to prevent division by zero</span></span>
<span id="cb41-319"><a href="#cb41-319" aria-hidden="true" tabindex="-1"></a>eps <span class="op">=</span> <span class="fl">1e-8</span></span>
<span id="cb41-320"><a href="#cb41-320" aria-hidden="true" tabindex="-1"></a>arr_norm <span class="op">=</span> (arr <span class="op">-</span> mins[:, <span class="va">None</span>, <span class="va">None</span>]) <span class="op">/</span> (np.maximum(ranges, eps)[:, <span class="va">None</span>, <span class="va">None</span>])</span>
<span id="cb41-321"><a href="#cb41-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-322"><a href="#cb41-322" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Normalized to [0,1] range:"</span>)</span>
<span id="cb41-323"><a href="#cb41-323" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Per-band min/max after normalization:"</span>)</span>
<span id="cb41-324"><a href="#cb41-324" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, band <span class="kw">in</span> <span class="bu">enumerate</span>(arr_norm):</span>
<span id="cb41-325"><a href="#cb41-325" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span><span class="bu">float</span>(band.<span class="bu">min</span>())<span class="sc">:.3f}</span><span class="ss"> to </span><span class="sc">{</span><span class="bu">float</span>(band.<span class="bu">max</span>())<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb41-326"><a href="#cb41-326" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-327"><a href="#cb41-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-328"><a href="#cb41-328" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing the normalization effect</span></span>
<span id="cb41-329"><a href="#cb41-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-330"><a href="#cb41-330" aria-hidden="true" tabindex="-1"></a>Let's examine how normalization changes the distribution of pixel values. This visualization helps us understand both what we've gained (comparable scales) and what we've preserved (relative patterns within each band).</span>
<span id="cb41-331"><a href="#cb41-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-334"><a href="#cb41-334" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-335"><a href="#cb41-335" aria-hidden="true" tabindex="-1"></a><span class="co"># | echo: true</span></span>
<span id="cb41-336"><a href="#cb41-336" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare distributions before and after normalization</span></span>
<span id="cb41-337"><a href="#cb41-337" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb41-338"><a href="#cb41-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-339"><a href="#cb41-339" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">3</span>, arr.shape[<span class="dv">0</span>])):</span>
<span id="cb41-340"><a href="#cb41-340" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Raw data histogram</span></span>
<span id="cb41-341"><a href="#cb41-341" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].hist(arr[i].ravel(), bins<span class="op">=</span><span class="dv">50</span>, color<span class="op">=</span><span class="st">'gray'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb41-342"><a href="#cb41-342" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_title(<span class="ss">f"Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Raw DNs"</span>)</span>
<span id="cb41-343"><a href="#cb41-343" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_xlabel(<span class="st">"Digital Number"</span>)</span>
<span id="cb41-344"><a href="#cb41-344" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">0</span>, i].set_ylabel(<span class="st">"Frequency"</span>)</span>
<span id="cb41-345"><a href="#cb41-345" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-346"><a href="#cb41-346" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Normalized data histogram  </span></span>
<span id="cb41-347"><a href="#cb41-347" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].hist(arr_norm[i].ravel(), bins<span class="op">=</span><span class="dv">50</span>, color<span class="op">=</span><span class="st">'steelblue'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>, edgecolor<span class="op">=</span><span class="st">'black'</span>)</span>
<span id="cb41-348"><a href="#cb41-348" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_title(<span class="ss">f"Band </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: Normalized [0,1]"</span>)</span>
<span id="cb41-349"><a href="#cb41-349" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_xlabel(<span class="st">"Normalized Value"</span>)</span>
<span id="cb41-350"><a href="#cb41-350" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_ylabel(<span class="st">"Frequency"</span>)</span>
<span id="cb41-351"><a href="#cb41-351" aria-hidden="true" tabindex="-1"></a>    axes[<span class="dv">1</span>, i].set_xlim(<span class="dv">0</span>, <span class="dv">1</span>)  <span class="co"># Fix scale to show [0,1] range</span></span>
<span id="cb41-352"><a href="#cb41-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-353"><a href="#cb41-353" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Distribution Comparison: Raw vs. Normalized"</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb41-354"><a href="#cb41-354" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb41-355"><a href="#cb41-355" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb41-356"><a href="#cb41-356" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-357"><a href="#cb41-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-358"><a href="#cb41-358" aria-hidden="true" tabindex="-1"></a>Notice how the histograms show that while the scales have changed dramatically, the shape of each distribution—the relative patterns of light and dark areas—remains exactly the same. We've made the bands comparable without losing the information that distinguishes different materials and land cover types.</span>
<span id="cb41-359"><a href="#cb41-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-360"><a href="#cb41-360" aria-hidden="true" tabindex="-1"></a>:::{.callout-tip}</span>
<span id="cb41-361"><a href="#cb41-361" aria-hidden="true" tabindex="-1"></a><span class="fu">## Historgram equalization</span></span>
<span id="cb41-362"><a href="#cb41-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-363"><a href="#cb41-363" aria-hidden="true" tabindex="-1"></a>**What to notice**</span>
<span id="cb41-364"><a href="#cb41-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-365"><a href="#cb41-365" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The raw data shows very different scales across bands (different x-axis ranges)</span>
<span id="cb41-366"><a href="#cb41-366" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>After normalization, all bands span <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span> but keep their unique distribution shapes</span>
<span id="cb41-367"><a href="#cb41-367" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>This transformation makes bands equally "visible" to the neural network while preserving the spectral signatures that matter for classification</span>
<span id="cb41-368"><a href="#cb41-368" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb41-369"><a href="#cb41-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-370"><a href="#cb41-370" aria-hidden="true" tabindex="-1"></a>Why this matters: Proper normalization is essential for stable training and ensures all spectral bands contribute meaningfully to the model's understanding of the landscape.</span>
<span id="cb41-371"><a href="#cb41-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-372"><a href="#cb41-372" aria-hidden="true" tabindex="-1"></a>:::{.callout-tip}</span>
<span id="cb41-373"><a href="#cb41-373" aria-hidden="true" tabindex="-1"></a><span class="fu">## Deeper Dive: Normalization Method Comparison</span></span>
<span id="cb41-374"><a href="#cb41-374" aria-hidden="true" tabindex="-1"></a>For a comprehensive analysis of different normalization approaches used in state-of-the-art geospatial foundation models (including Prithvi, SatMAE, and Clay), see our detailed <span class="co">[</span><span class="ot">Normalization Methods Comparison</span><span class="co">](../examples/normalization_comparison.qmd)</span>. This example compares computational performance, robustness to outliers, and practical trade-offs between five different normalization strategies.</span>
<span id="cb41-375"><a href="#cb41-375" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb41-376"><a href="#cb41-376" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb41-377"><a href="#cb41-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-378"><a href="#cb41-378" aria-hidden="true" tabindex="-1"></a><span class="fu">## 1.3 Tiling and patch extraction ✂️</span></span>
<span id="cb41-379"><a href="#cb41-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-380"><a href="#cb41-380" aria-hidden="true" tabindex="-1"></a>*This section covers the patch extraction step in our roadmap: splitting large images into manageable "tokens" for model processing.*</span>
<span id="cb41-381"><a href="#cb41-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-382"><a href="#cb41-382" aria-hidden="true" tabindex="-1"></a><span class="fu">### Why do we need patches?</span></span>
<span id="cb41-383"><a href="#cb41-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-384"><a href="#cb41-384" aria-hidden="true" tabindex="-1"></a>When working with satellite imagery, we face a fundamental challenge: **scale mismatch**. A typical satellite image might be 10,000×10,000 pixels or larger, but neural networks work best with much smaller, consistent input sizes. But there's more to it than just computational limits. Patches serve several critical functions in geospatial machine learning:</span>
<span id="cb41-385"><a href="#cb41-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-386"><a href="#cb41-386" aria-hidden="true" tabindex="-1"></a>**🧠 Cognitive Focus**: Just as humans focus on local areas when interpreting landscapes, neural networks learn more effectively when they can concentrate on coherent spatial neighborhoods rather than trying to process vast areas simultaneously.</span>
<span id="cb41-387"><a href="#cb41-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-388"><a href="#cb41-388" aria-hidden="true" tabindex="-1"></a>**⚡ Computational Efficiency**: Smaller patches fit in GPU memory and enable parallel processing. We can train on batches of patches rather than one massive image at a time.</span>
<span id="cb41-389"><a href="#cb41-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-390"><a href="#cb41-390" aria-hidden="true" tabindex="-1"></a>**🎯 Consistent Learning**: Fixed-size patches ensure the model sees consistent input dimensions, enabling it to learn spatial patterns at a specific scale.</span>
<span id="cb41-391"><a href="#cb41-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-392"><a href="#cb41-392" aria-hidden="true" tabindex="-1"></a>**🔄 Data Augmentation**: From one large image, we can extract hundreds or thousands of training patches, dramatically increasing our dataset size.</span>
<span id="cb41-393"><a href="#cb41-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-394"><a href="#cb41-394" aria-hidden="true" tabindex="-1"></a><span class="fu">### The tokenization analogy</span></span>
<span id="cb41-395"><a href="#cb41-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-396"><a href="#cb41-396" aria-hidden="true" tabindex="-1"></a>The relationship between patches and tokenization runs deeper than you might first think. Let's explore this analogy:</span>
<span id="cb41-397"><a href="#cb41-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-398"><a href="#cb41-398" aria-hidden="true" tabindex="-1"></a>| Aspect | Text Processing | Geospatial Processing |</span>
<span id="cb41-399"><a href="#cb41-399" aria-hidden="true" tabindex="-1"></a>|--------|----------------|----------------------|</span>
<span id="cb41-400"><a href="#cb41-400" aria-hidden="true" tabindex="-1"></a>| **Raw Input** | Documents, articles, books | Large satellite images, map tiles |</span>
<span id="cb41-401"><a href="#cb41-401" aria-hidden="true" tabindex="-1"></a>| **Atomic Unit** | Words/subwords → tokens | Pixels → patches |</span>
<span id="cb41-402"><a href="#cb41-402" aria-hidden="true" tabindex="-1"></a>| **Why Split?** | Models can't process infinite text | Models can't process arbitrarily large images |</span>
<span id="cb41-403"><a href="#cb41-403" aria-hidden="true" tabindex="-1"></a>| **Context Window** | Limited token context (e.g., 4K tokens) | Limited spatial context (e.g., 64×64 pixels) |</span>
<span id="cb41-404"><a href="#cb41-404" aria-hidden="true" tabindex="-1"></a>| **Semantic Coherence** | Tokens preserve word meaning | Patches preserve local spatial patterns |</span>
<span id="cb41-405"><a href="#cb41-405" aria-hidden="true" tabindex="-1"></a>| **Position Matters** | Word order affects meaning | Spatial arrangement affects interpretation |</span>
<span id="cb41-406"><a href="#cb41-406" aria-hidden="true" tabindex="-1"></a>| **Overlapping Context** | Sliding windows for long documents | Overlapping patches for spatial continuity |</span>
<span id="cb41-407"><a href="#cb41-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-408"><a href="#cb41-408" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing the patch extraction process</span></span>
<span id="cb41-409"><a href="#cb41-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-410"><a href="#cb41-410" aria-hidden="true" tabindex="-1"></a>Now we'll implement the patch extraction step from our roadmap. This transforms our normalized image into a collection of spatial "tokens" that our model can process.</span>
<span id="cb41-411"><a href="#cb41-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-412"><a href="#cb41-412" aria-hidden="true" tabindex="-1"></a><span class="fu">### Understanding patch size trade-offs</span></span>
<span id="cb41-413"><a href="#cb41-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-414"><a href="#cb41-414" aria-hidden="true" tabindex="-1"></a>Before we extract patches, it's important to understand how patch size affects what our model can learn:</span>
<span id="cb41-415"><a href="#cb41-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-416"><a href="#cb41-416" aria-hidden="true" tabindex="-1"></a>| Patch Size | Pros | Cons | Best Use Cases |</span>
<span id="cb41-417"><a href="#cb41-417" aria-hidden="true" tabindex="-1"></a>|------------|------|------|----------------|</span>
<span id="cb41-418"><a href="#cb41-418" aria-hidden="true" tabindex="-1"></a>| **Small (16×16, 32×32)** | Fine detail, many samples, fast processing | Limited context, may miss large features | Urban analysis, crop monitoring |</span>
<span id="cb41-419"><a href="#cb41-419" aria-hidden="true" tabindex="-1"></a>| **Medium (64×64, 128×128)** | Good balance of detail and context | Moderate computational cost | General purpose, land cover mapping |</span>
<span id="cb41-420"><a href="#cb41-420" aria-hidden="true" tabindex="-1"></a>| **Large (256×256, 512×512)** | Rich spatial context, captures large features | Fewer samples, more memory intensive | Landscape analysis, climate modeling |</span>
<span id="cb41-421"><a href="#cb41-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-422"><a href="#cb41-422" aria-hidden="true" tabindex="-1"></a>For our exercise, we'll use 64×64 patches—a sweet spot that captures meaningful spatial patterns while remaining computationally manageable.</span>
<span id="cb41-423"><a href="#cb41-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-424"><a href="#cb41-424" aria-hidden="true" tabindex="-1"></a><span class="fu">### Step-by-step patch extraction</span></span>
<span id="cb41-425"><a href="#cb41-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-426"><a href="#cb41-426" aria-hidden="true" tabindex="-1"></a>Now let's implement patch extraction with detailed visualization of each step:</span>
<span id="cb41-427"><a href="#cb41-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-430"><a href="#cb41-430" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-431"><a href="#cb41-431" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-432"><a href="#cb41-432" aria-hidden="true" tabindex="-1"></a><span class="co"># First, let's examine our normalized image dimensions</span></span>
<span id="cb41-433"><a href="#cb41-433" aria-hidden="true" tabindex="-1"></a>C, H, W <span class="op">=</span> arr_norm.shape</span>
<span id="cb41-434"><a href="#cb41-434" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Input image shape: </span><span class="sc">{</span>C<span class="sc">}</span><span class="ss"> bands × </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss"> height × </span><span class="sc">{</span>W<span class="sc">}</span><span class="ss"> width pixels"</span>)</span>
<span id="cb41-435"><a href="#cb41-435" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Using patch size: </span><span class="sc">{</span>PATCH_SIZE<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>PATCH_SIZE<span class="sc">}</span><span class="ss"> pixels"</span>)</span>
<span id="cb41-436"><a href="#cb41-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-437"><a href="#cb41-437" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate how many complete patches we can extract</span></span>
<span id="cb41-438"><a href="#cb41-438" aria-hidden="true" tabindex="-1"></a>ph <span class="op">=</span> H <span class="op">//</span> PATCH_SIZE  <span class="co"># patches vertically</span></span>
<span id="cb41-439"><a href="#cb41-439" aria-hidden="true" tabindex="-1"></a>pw <span class="op">=</span> W <span class="op">//</span> PATCH_SIZE  <span class="co"># patches horizontally</span></span>
<span id="cb41-440"><a href="#cb41-440" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Complete patches: </span><span class="sc">{</span>ph<span class="sc">}</span><span class="ss"> rows × </span><span class="sc">{</span>pw<span class="sc">}</span><span class="ss"> columns = </span><span class="sc">{</span>ph <span class="op">*</span> pw<span class="sc">}</span><span class="ss"> total patches"</span>)</span>
<span id="cb41-441"><a href="#cb41-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-442"><a href="#cb41-442" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the cropped dimensions (we may lose edge pixels)</span></span>
<span id="cb41-443"><a href="#cb41-443" aria-hidden="true" tabindex="-1"></a>Hc, Wc <span class="op">=</span> ph <span class="op">*</span> PATCH_SIZE, pw <span class="op">*</span> PATCH_SIZE</span>
<span id="cb41-444"><a href="#cb41-444" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Cropped image size: </span><span class="sc">{</span>Hc<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>Wc<span class="sc">}</span><span class="ss"> (original: </span><span class="sc">{</span>H<span class="sc">}</span><span class="ss">×</span><span class="sc">{</span>W<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb41-445"><a href="#cb41-445" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Edge pixels lost: </span><span class="sc">{</span>H<span class="op">-</span>Hc<span class="sc">}</span><span class="ss"> height, </span><span class="sc">{</span>W<span class="op">-</span>Wc<span class="sc">}</span><span class="ss"> width"</span>)</span>
<span id="cb41-446"><a href="#cb41-446" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-447"><a href="#cb41-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-450"><a href="#cb41-450" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-451"><a href="#cb41-451" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-452"><a href="#cb41-452" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1: Crop the image to fit complete patches</span></span>
<span id="cb41-453"><a href="#cb41-453" aria-hidden="true" tabindex="-1"></a>arr_c <span class="op">=</span> arr_norm[:, :Hc, :Wc]</span>
<span id="cb41-454"><a href="#cb41-454" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Cropped array shape: </span><span class="sc">{</span>arr_c<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb41-455"><a href="#cb41-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-456"><a href="#cb41-456" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2: Visualize the grid overlay on the original image</span></span>
<span id="cb41-457"><a href="#cb41-457" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2) <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">5</span>))</span>
<span id="cb41-458"><a href="#cb41-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-459"><a href="#cb41-459" aria-hidden="true" tabindex="-1"></a><span class="co"># Show original image with patch grid overlay</span></span>
<span id="cb41-460"><a href="#cb41-460" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> C <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb41-461"><a href="#cb41-461" aria-hidden="true" tabindex="-1"></a>    rgb <span class="op">=</span> np.transpose(arr_norm[:<span class="dv">3</span>], (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>))</span>
<span id="cb41-462"><a href="#cb41-462" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb41-463"><a href="#cb41-463" aria-hidden="true" tabindex="-1"></a>    rgb <span class="op">=</span> np.stack([arr_norm[<span class="dv">0</span>]]<span class="op">*</span><span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb41-464"><a href="#cb41-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-465"><a href="#cb41-465" aria-hidden="true" tabindex="-1"></a>ax1.imshow(np.clip(rgb, <span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb41-466"><a href="#cb41-466" aria-hidden="true" tabindex="-1"></a>ax1.set_title(<span class="st">"Original Image with Patch Grid"</span>)</span>
<span id="cb41-467"><a href="#cb41-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-468"><a href="#cb41-468" aria-hidden="true" tabindex="-1"></a><span class="co"># Draw grid lines to show patch boundaries</span></span>
<span id="cb41-469"><a href="#cb41-469" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ph <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb41-470"><a href="#cb41-470" aria-hidden="true" tabindex="-1"></a>    ax1.axhline(y<span class="op">=</span>i <span class="op">*</span> PATCH_SIZE <span class="op">-</span> <span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb41-471"><a href="#cb41-471" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(pw <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb41-472"><a href="#cb41-472" aria-hidden="true" tabindex="-1"></a>    ax1.axvline(x<span class="op">=</span>j <span class="op">*</span> PATCH_SIZE <span class="op">-</span> <span class="fl">0.5</span>, color<span class="op">=</span><span class="st">'red'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb41-473"><a href="#cb41-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-474"><a href="#cb41-474" aria-hidden="true" tabindex="-1"></a><span class="co"># Show cropped version</span></span>
<span id="cb41-475"><a href="#cb41-475" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> C <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb41-476"><a href="#cb41-476" aria-hidden="true" tabindex="-1"></a>    rgb_cropped <span class="op">=</span> np.transpose(arr_c[:<span class="dv">3</span>], (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>))</span>
<span id="cb41-477"><a href="#cb41-477" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb41-478"><a href="#cb41-478" aria-hidden="true" tabindex="-1"></a>    rgb_cropped <span class="op">=</span> np.stack([arr_c[<span class="dv">0</span>]]<span class="op">*</span><span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb41-479"><a href="#cb41-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-480"><a href="#cb41-480" aria-hidden="true" tabindex="-1"></a>ax2.imshow(np.clip(rgb_cropped, <span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb41-481"><a href="#cb41-481" aria-hidden="true" tabindex="-1"></a>ax2.set_title(<span class="st">"Cropped Image (Complete Patches Only)"</span>)</span>
<span id="cb41-482"><a href="#cb41-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-483"><a href="#cb41-483" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb41-484"><a href="#cb41-484" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb41-485"><a href="#cb41-485" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-486"><a href="#cb41-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-489"><a href="#cb41-489" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-490"><a href="#cb41-490" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-491"><a href="#cb41-491" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3: The magical reshape operation that extracts patches</span></span>
<span id="cb41-492"><a href="#cb41-492" aria-hidden="true" tabindex="-1"></a><span class="co"># This is the core of patch extraction - let's break it down step by step</span></span>
<span id="cb41-493"><a href="#cb41-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-494"><a href="#cb41-494" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"🔄 Patch extraction transformation:"</span>)</span>
<span id="cb41-495"><a href="#cb41-495" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"1. Input shape: </span><span class="sc">{</span>arr_c<span class="sc">.</span>shape<span class="sc">}</span><span class="ss"> → (bands, height, width)"</span>)</span>
<span id="cb41-496"><a href="#cb41-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-497"><a href="#cb41-497" aria-hidden="true" tabindex="-1"></a><span class="co"># Reshape to separate patch rows and columns</span></span>
<span id="cb41-498"><a href="#cb41-498" aria-hidden="true" tabindex="-1"></a>reshaped <span class="op">=</span> arr_c.reshape(C, ph, PATCH_SIZE, pw, PATCH_SIZE)</span>
<span id="cb41-499"><a href="#cb41-499" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"2. After reshape: </span><span class="sc">{</span>reshaped<span class="sc">.</span>shape<span class="sc">}</span><span class="ss"> → (bands, patch_rows, patch_height, patch_cols, patch_width)"</span>)</span>
<span id="cb41-500"><a href="#cb41-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-501"><a href="#cb41-501" aria-hidden="true" tabindex="-1"></a><span class="co"># Transpose to group patches together</span></span>
<span id="cb41-502"><a href="#cb41-502" aria-hidden="true" tabindex="-1"></a>transposed <span class="op">=</span> reshaped.transpose(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb41-503"><a href="#cb41-503" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"3. After transpose: </span><span class="sc">{</span>transposed<span class="sc">.</span>shape<span class="sc">}</span><span class="ss"> → (patch_rows, patch_cols, bands, patch_height, patch_width)"</span>)</span>
<span id="cb41-504"><a href="#cb41-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-505"><a href="#cb41-505" aria-hidden="true" tabindex="-1"></a><span class="co"># Final reshape to get individual patches</span></span>
<span id="cb41-506"><a href="#cb41-506" aria-hidden="true" tabindex="-1"></a>patches <span class="op">=</span> transposed.reshape(ph <span class="op">*</span> pw, C, PATCH_SIZE, PATCH_SIZE)</span>
<span id="cb41-507"><a href="#cb41-507" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"4. Final patches: </span><span class="sc">{</span>patches<span class="sc">.</span>shape<span class="sc">}</span><span class="ss"> → (num_patches, bands, patch_height, patch_width)"</span>)</span>
<span id="cb41-508"><a href="#cb41-508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-509"><a href="#cb41-509" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">✅ Successfully extracted </span><span class="sc">{</span>patches<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> patches!"</span>)</span>
<span id="cb41-510"><a href="#cb41-510" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-511"><a href="#cb41-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-514"><a href="#cb41-514" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-515"><a href="#cb41-515" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-516"><a href="#cb41-516" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4: Visualize sample patches to see what we've extracted</span></span>
<span id="cb41-517"><a href="#cb41-517" aria-hidden="true" tabindex="-1"></a>nshow <span class="op">=</span> <span class="bu">min</span>(<span class="dv">6</span>, <span class="bu">len</span>(patches))</span>
<span id="cb41-518"><a href="#cb41-518" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">8</span>))</span>
<span id="cb41-519"><a href="#cb41-519" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> axes.flatten()</span>
<span id="cb41-520"><a href="#cb41-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-521"><a href="#cb41-521" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nshow):</span>
<span id="cb41-522"><a href="#cb41-522" aria-hidden="true" tabindex="-1"></a>    p <span class="op">=</span> patches[i]</span>
<span id="cb41-523"><a href="#cb41-523" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-524"><a href="#cb41-524" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create RGB visualization (handle cases with fewer than 3 bands)</span></span>
<span id="cb41-525"><a href="#cb41-525" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> C <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb41-526"><a href="#cb41-526" aria-hidden="true" tabindex="-1"></a>        rgb <span class="op">=</span> np.transpose(p[:<span class="dv">3</span>], (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>))</span>
<span id="cb41-527"><a href="#cb41-527" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb41-528"><a href="#cb41-528" aria-hidden="true" tabindex="-1"></a>        rgb <span class="op">=</span> np.stack([p[<span class="dv">0</span>]]<span class="op">*</span><span class="dv">3</span>, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb41-529"><a href="#cb41-529" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-530"><a href="#cb41-530" aria-hidden="true" tabindex="-1"></a>    axes[i].imshow(np.clip(rgb, <span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb41-531"><a href="#cb41-531" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb41-532"><a href="#cb41-532" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate patch position in the grid</span></span>
<span id="cb41-533"><a href="#cb41-533" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> i <span class="op">//</span> pw</span>
<span id="cb41-534"><a href="#cb41-534" aria-hidden="true" tabindex="-1"></a>    col <span class="op">=</span> i <span class="op">%</span> pw</span>
<span id="cb41-535"><a href="#cb41-535" aria-hidden="true" tabindex="-1"></a>    axes[i].set_title(<span class="ss">f"Patch </span><span class="sc">{</span>i<span class="sc">}</span><span class="ch">\n</span><span class="ss">Grid position: (</span><span class="sc">{</span>row<span class="sc">}</span><span class="ss">, </span><span class="sc">{</span>col<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb41-536"><a href="#cb41-536" aria-hidden="true" tabindex="-1"></a>    axes[i].axis(<span class="st">'off'</span>)</span>
<span id="cb41-537"><a href="#cb41-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-538"><a href="#cb41-538" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">"Sample Patches: Our Image 'Tokens'"</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb41-539"><a href="#cb41-539" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb41-540"><a href="#cb41-540" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb41-541"><a href="#cb41-541" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-542"><a href="#cb41-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-543"><a href="#cb41-543" aria-hidden="true" tabindex="-1"></a><span class="fu">### Understanding what we've created</span></span>
<span id="cb41-544"><a href="#cb41-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-545"><a href="#cb41-545" aria-hidden="true" tabindex="-1"></a>Each patch is now a self-contained "token" that represents a local region of our satellite image. Just like how words in a sentence carry meaning individually but also depend on context, these patches contain local spatial patterns while maintaining relationships to their neighboring patches.</span>
<span id="cb41-546"><a href="#cb41-546" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-547"><a href="#cb41-547" aria-hidden="true" tabindex="-1"></a>:::{.callout-note}</span>
<span id="cb41-548"><a href="#cb41-548" aria-hidden="true" tabindex="-1"></a><span class="fu">## Key Transformation</span></span>
<span id="cb41-549"><a href="#cb41-549" aria-hidden="true" tabindex="-1"></a>We've transformed one large image <span class="in">`(3, H, W)`</span> into <span class="in">`{ph × pw}`</span> smaller images, each of shape <span class="in">`(3, 64, 64)`</span>. This is exactly analogous to how tokenization transforms one long text into many smaller tokens that a model can process efficiently.</span>
<span id="cb41-550"><a href="#cb41-550" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb41-551"><a href="#cb41-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-552"><a href="#cb41-552" aria-hidden="true" tabindex="-1"></a>Why this matters: Patches become our fundamental unit of analysis—each patch can be processed independently while preserving spatial relationships for the model to learn landscape patterns.</span>
<span id="cb41-553"><a href="#cb41-553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-554"><a href="#cb41-554" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb41-555"><a href="#cb41-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-556"><a href="#cb41-556" aria-hidden="true" tabindex="-1"></a><span class="fu">## 1.4 Assigning patch IDs &amp; metadata 🏷️</span></span>
<span id="cb41-557"><a href="#cb41-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-558"><a href="#cb41-558" aria-hidden="true" tabindex="-1"></a>*This section covers the metadata step in our roadmap: giving each patch an identity and spatial context.*</span>
<span id="cb41-559"><a href="#cb41-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-560"><a href="#cb41-560" aria-hidden="true" tabindex="-1"></a>"Every patch needs an identity — not just for bookkeeping, but to remember where and when it came from."</span>
<span id="cb41-561"><a href="#cb41-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-562"><a href="#cb41-562" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Generate unique IDs for patches.</span>
<span id="cb41-563"><a href="#cb41-563" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Store spatial metadata (bounding box, CRS) and acquisition info.</span>
<span id="cb41-564"><a href="#cb41-564" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Print one sample metadata record.</span>
<span id="cb41-565"><a href="#cb41-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-568"><a href="#cb41-568" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-569"><a href="#cb41-569" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-570"><a href="#cb41-570" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> rasterio.transform <span class="im">import</span> xy</span>
<span id="cb41-571"><a href="#cb41-571" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-572"><a href="#cb41-572" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute patch bounding boxes (min lon/lat, max lon/lat approx)</span></span>
<span id="cb41-573"><a href="#cb41-573" aria-hidden="true" tabindex="-1"></a>ids <span class="op">=</span> []</span>
<span id="cb41-574"><a href="#cb41-574" aria-hidden="true" tabindex="-1"></a>meta <span class="op">=</span> []</span>
<span id="cb41-575"><a href="#cb41-575" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb41-576"><a href="#cb41-576" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ph):</span>
<span id="cb41-577"><a href="#cb41-577" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(pw):</span>
<span id="cb41-578"><a href="#cb41-578" aria-hidden="true" tabindex="-1"></a>        pid <span class="op">=</span> <span class="ss">f"patch_</span><span class="sc">{</span>i<span class="sc">:03d}</span><span class="ss">_</span><span class="sc">{</span>j<span class="sc">:03d}</span><span class="ss">"</span></span>
<span id="cb41-579"><a href="#cb41-579" aria-hidden="true" tabindex="-1"></a>        <span class="co"># top-left pixel (row=i*P, col=j*P)</span></span>
<span id="cb41-580"><a href="#cb41-580" aria-hidden="true" tabindex="-1"></a>        r0, c0 <span class="op">=</span> i<span class="op">*</span>PATCH_SIZE, j<span class="op">*</span>PATCH_SIZE</span>
<span id="cb41-581"><a href="#cb41-581" aria-hidden="true" tabindex="-1"></a>        r1, c1 <span class="op">=</span> r0 <span class="op">+</span> PATCH_SIZE <span class="op">-</span> <span class="dv">1</span>, j <span class="op">*</span> PATCH_SIZE <span class="op">+</span> PATCH_SIZE <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb41-582"><a href="#cb41-582" aria-hidden="true" tabindex="-1"></a>        (x0, y0) <span class="op">=</span> xy(transform, r0, c0)</span>
<span id="cb41-583"><a href="#cb41-583" aria-hidden="true" tabindex="-1"></a>        (x1, y1) <span class="op">=</span> xy(transform, r1, c1)</span>
<span id="cb41-584"><a href="#cb41-584" aria-hidden="true" tabindex="-1"></a>        bbox <span class="op">=</span> (<span class="bu">min</span>(x0,x1), <span class="bu">min</span>(y0,y1), <span class="bu">max</span>(x0,x1), <span class="bu">max</span>(y0,y1))</span>
<span id="cb41-585"><a href="#cb41-585" aria-hidden="true" tabindex="-1"></a>        ids.append(pid)</span>
<span id="cb41-586"><a href="#cb41-586" aria-hidden="true" tabindex="-1"></a>        meta.append({<span class="st">"id"</span>: pid, <span class="st">"bbox"</span>: bbox, <span class="st">"crs"</span>: <span class="bu">str</span>(crs)})</span>
<span id="cb41-587"><a href="#cb41-587" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb41-588"><a href="#cb41-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-589"><a href="#cb41-589" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"total ids:"</span>, <span class="bu">len</span>(ids))</span>
<span id="cb41-590"><a href="#cb41-590" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"sample record:"</span>, meta[<span class="dv">0</span>])</span>
<span id="cb41-591"><a href="#cb41-591" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-592"><a href="#cb41-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-593"><a href="#cb41-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-594"><a href="#cb41-594" aria-hidden="true" tabindex="-1"></a>Why this matters: metadata lets us track location/time and avoid leakage when splitting data.</span>
<span id="cb41-595"><a href="#cb41-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-596"><a href="#cb41-596" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb41-597"><a href="#cb41-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-598"><a href="#cb41-598" aria-hidden="true" tabindex="-1"></a><span class="fu">## 1.5 Adding special context tokens (location, time, sensor) 🌍</span></span>
<span id="cb41-599"><a href="#cb41-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-600"><a href="#cb41-600" aria-hidden="true" tabindex="-1"></a>*This section covers the spatial-temporal context step in our roadmap: encoding where and when each patch was captured.*</span>
<span id="cb41-601"><a href="#cb41-601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-602"><a href="#cb41-602" aria-hidden="true" tabindex="-1"></a>"In addition to pixel values, our model benefits from knowing where and when the data was collected, and by which sensor."</span>
<span id="cb41-603"><a href="#cb41-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-604"><a href="#cb41-604" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Encode lat/lon as continuous features or sinusoidal embeddings.</span>
<span id="cb41-605"><a href="#cb41-605" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Encode acquisition date as day‑of‑year + year.</span>
<span id="cb41-606"><a href="#cb41-606" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Show how these features attach to patches.</span>
<span id="cb41-607"><a href="#cb41-607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-610"><a href="#cb41-610" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-611"><a href="#cb41-611" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-612"><a href="#cb41-612" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> datetime <span class="im">as</span> dt</span>
<span id="cb41-613"><a href="#cb41-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-614"><a href="#cb41-614" aria-hidden="true" tabindex="-1"></a><span class="co"># Example acquisition date (placeholder metadata)</span></span>
<span id="cb41-615"><a href="#cb41-615" aria-hidden="true" tabindex="-1"></a>acq_date <span class="op">=</span> dt.date(<span class="dv">2023</span>, <span class="dv">7</span>, <span class="dv">15</span>)</span>
<span id="cb41-616"><a href="#cb41-616" aria-hidden="true" tabindex="-1"></a>doy <span class="op">=</span> acq_date.timetuple().tm_yday</span>
<span id="cb41-617"><a href="#cb41-617" aria-hidden="true" tabindex="-1"></a>year <span class="op">=</span> acq_date.year</span>
<span id="cb41-618"><a href="#cb41-618" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-619"><a href="#cb41-619" aria-hidden="true" tabindex="-1"></a><span class="co"># Use patch centers for location features</span></span>
<span id="cb41-620"><a href="#cb41-620" aria-hidden="true" tabindex="-1"></a>centers <span class="op">=</span> []</span>
<span id="cb41-621"><a href="#cb41-621" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ph):</span>
<span id="cb41-622"><a href="#cb41-622" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(pw):</span>
<span id="cb41-623"><a href="#cb41-623" aria-hidden="true" tabindex="-1"></a>        r, c <span class="op">=</span> i<span class="op">*</span>PATCH_SIZE <span class="op">+</span> PATCH_SIZE<span class="op">//</span><span class="dv">2</span>, j<span class="op">*</span>PATCH_SIZE <span class="op">+</span> PATCH_SIZE<span class="op">//</span><span class="dv">2</span></span>
<span id="cb41-624"><a href="#cb41-624" aria-hidden="true" tabindex="-1"></a>        x_c, y_c <span class="op">=</span> xy(transform, r, c)</span>
<span id="cb41-625"><a href="#cb41-625" aria-hidden="true" tabindex="-1"></a>        centers.append((x_c, y_c))</span>
<span id="cb41-626"><a href="#cb41-626" aria-hidden="true" tabindex="-1"></a>centers <span class="op">=</span> np.array(centers, dtype<span class="op">=</span>np.float32)</span>
<span id="cb41-627"><a href="#cb41-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-628"><a href="#cb41-628" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple scaled features (you can swap for sinusoidal if desired)</span></span>
<span id="cb41-629"><a href="#cb41-629" aria-hidden="true" tabindex="-1"></a>loc_feat <span class="op">=</span> (centers <span class="op">-</span> centers.mean(<span class="dv">0</span>)) <span class="op">/</span> (centers.std(<span class="dv">0</span>) <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb41-630"><a href="#cb41-630" aria-hidden="true" tabindex="-1"></a>time_feat <span class="op">=</span> np.array([doy<span class="op">/</span><span class="fl">366.0</span>, (year<span class="op">-</span><span class="dv">2000</span>)<span class="op">/</span><span class="fl">50.0</span>], dtype<span class="op">=</span>np.float32)  <span class="co"># scale to ~[0,1]</span></span>
<span id="cb41-631"><a href="#cb41-631" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"loc_feat shape:"</span>, loc_feat.shape, <span class="st">"time_feat:"</span>, time_feat.tolist())</span>
<span id="cb41-632"><a href="#cb41-632" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-633"><a href="#cb41-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-634"><a href="#cb41-634" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-635"><a href="#cb41-635" aria-hidden="true" tabindex="-1"></a>Why this matters: models need context to learn spatial/temporal patterns.</span>
<span id="cb41-636"><a href="#cb41-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-637"><a href="#cb41-637" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb41-638"><a href="#cb41-638" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-639"><a href="#cb41-639" aria-hidden="true" tabindex="-1"></a><span class="fu">## 1.6 Dimensionality reduction for spectral bands (analogy to BPE)</span></span>
<span id="cb41-640"><a href="#cb41-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-641"><a href="#cb41-641" aria-hidden="true" tabindex="-1"></a>“Sometimes we have more bands than the model needs. We can reduce the input size while keeping the most useful information.”</span>
<span id="cb41-642"><a href="#cb41-642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-643"><a href="#cb41-643" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Demonstrate PCA or band selection.</span>
<span id="cb41-644"><a href="#cb41-644" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Compare original vs. reduced band profiles.</span>
<span id="cb41-645"><a href="#cb41-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-648"><a href="#cb41-648" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-649"><a href="#cb41-649" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-650"><a href="#cb41-650" aria-hidden="true" tabindex="-1"></a><span class="co"># PCA via SVD on (pixels, bands) for speed; sample a subset of pixels</span></span>
<span id="cb41-651"><a href="#cb41-651" aria-hidden="true" tabindex="-1"></a>C, Hc, Wc <span class="op">=</span> arr_c.shape</span>
<span id="cb41-652"><a href="#cb41-652" aria-hidden="true" tabindex="-1"></a>pixels <span class="op">=</span> arr_c.reshape(C, <span class="op">-</span><span class="dv">1</span>).T  <span class="co"># (N, C)</span></span>
<span id="cb41-653"><a href="#cb41-653" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> pixels.shape[<span class="dv">0</span>]</span>
<span id="cb41-654"><a href="#cb41-654" aria-hidden="true" tabindex="-1"></a>sub <span class="op">=</span> <span class="bu">min</span>(<span class="dv">5000</span>, N)</span>
<span id="cb41-655"><a href="#cb41-655" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> np.random.default_rng(RNG_SEED).choice(N, sub, replace<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb41-656"><a href="#cb41-656" aria-hidden="true" tabindex="-1"></a>Xsub <span class="op">=</span> pixels[idx]</span>
<span id="cb41-657"><a href="#cb41-657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-658"><a href="#cb41-658" aria-hidden="true" tabindex="-1"></a><span class="co"># Center</span></span>
<span id="cb41-659"><a href="#cb41-659" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> Xsub.mean(<span class="dv">0</span>, keepdims<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb41-660"><a href="#cb41-660" aria-hidden="true" tabindex="-1"></a>Xc <span class="op">=</span> Xsub <span class="op">-</span> mu</span>
<span id="cb41-661"><a href="#cb41-661" aria-hidden="true" tabindex="-1"></a>U, S, Vt <span class="op">=</span> np.linalg.svd(Xc, full_matrices<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb41-662"><a href="#cb41-662" aria-hidden="true" tabindex="-1"></a>explained <span class="op">=</span> (S<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> (S<span class="op">**</span><span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb41-663"><a href="#cb41-663" aria-hidden="true" tabindex="-1"></a>keep <span class="op">=</span> <span class="bu">min</span>(<span class="dv">3</span>, C)</span>
<span id="cb41-664"><a href="#cb41-664" aria-hidden="true" tabindex="-1"></a>Wred <span class="op">=</span> Vt[:keep].T  <span class="co"># (C, keep)</span></span>
<span id="cb41-665"><a href="#cb41-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-666"><a href="#cb41-666" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"bands:"</span>, C, <span class="st">"keep:"</span>, keep, <span class="st">"explained_var@keep:"</span>, <span class="bu">float</span>(explained[:keep].<span class="bu">sum</span>()))</span>
<span id="cb41-667"><a href="#cb41-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-668"><a href="#cb41-668" aria-hidden="true" tabindex="-1"></a><span class="co"># Project full image to reduced components per pixel</span></span>
<span id="cb41-669"><a href="#cb41-669" aria-hidden="true" tabindex="-1"></a>red_pixels <span class="op">=</span> (pixels <span class="op">-</span> mu).dot(Wred)  <span class="co"># (N, keep)</span></span>
<span id="cb41-670"><a href="#cb41-670" aria-hidden="true" tabindex="-1"></a>red_stack <span class="op">=</span> red_pixels.T.reshape(keep, Hc, Wc)</span>
<span id="cb41-671"><a href="#cb41-671" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"reduced stack shape:"</span>, red_stack.shape)</span>
<span id="cb41-672"><a href="#cb41-672" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-673"><a href="#cb41-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-674"><a href="#cb41-674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-675"><a href="#cb41-675" aria-hidden="true" tabindex="-1"></a>Why this matters: reducing input size speeds training and may denoise bands.</span>
<span id="cb41-676"><a href="#cb41-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-677"><a href="#cb41-677" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb41-678"><a href="#cb41-678" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-679"><a href="#cb41-679" aria-hidden="true" tabindex="-1"></a><span class="fu">## 1.7 Sampling training patches (sliding windows, spatial splits)</span></span>
<span id="cb41-680"><a href="#cb41-680" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-681"><a href="#cb41-681" aria-hidden="true" tabindex="-1"></a>“Rather than using the whole dataset at once, we’ll sample patches in a way that keeps training efficient and avoids data leakage.”</span>
<span id="cb41-682"><a href="#cb41-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-683"><a href="#cb41-683" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Show random vs. sliding‑window sampling.</span>
<span id="cb41-684"><a href="#cb41-684" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Highlight spatial/temporal separation for validation/test.</span>
<span id="cb41-685"><a href="#cb41-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-688"><a href="#cb41-688" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-689"><a href="#cb41-689" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-690"><a href="#cb41-690" aria-hidden="true" tabindex="-1"></a>num_patches <span class="op">=</span> patches.shape[<span class="dv">0</span>]</span>
<span id="cb41-691"><a href="#cb41-691" aria-hidden="true" tabindex="-1"></a>all_idx <span class="op">=</span> np.arange(num_patches)</span>
<span id="cb41-692"><a href="#cb41-692" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple spatial split by rows: top 80% train, bottom 20% val</span></span>
<span id="cb41-693"><a href="#cb41-693" aria-hidden="true" tabindex="-1"></a>rows <span class="op">=</span> np.repeat(np.arange(ph), pw)</span>
<span id="cb41-694"><a href="#cb41-694" aria-hidden="true" tabindex="-1"></a>train_mask <span class="op">=</span> rows <span class="op">&lt;</span> <span class="bu">int</span>(<span class="fl">0.8</span><span class="op">*</span>ph)</span>
<span id="cb41-695"><a href="#cb41-695" aria-hidden="true" tabindex="-1"></a>train_idx <span class="op">=</span> all_idx[train_mask]</span>
<span id="cb41-696"><a href="#cb41-696" aria-hidden="true" tabindex="-1"></a>val_idx <span class="op">=</span> all_idx[<span class="op">~</span>train_mask]</span>
<span id="cb41-697"><a href="#cb41-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-698"><a href="#cb41-698" aria-hidden="true" tabindex="-1"></a>rng <span class="op">=</span> np.random.default_rng(RNG_SEED)</span>
<span id="cb41-699"><a href="#cb41-699" aria-hidden="true" tabindex="-1"></a>rng.shuffle(train_idx)</span>
<span id="cb41-700"><a href="#cb41-700" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"num_patches:"</span>, num_patches, <span class="st">"train:"</span>, <span class="bu">len</span>(train_idx), <span class="st">"val:"</span>, <span class="bu">len</span>(val_idx))</span>
<span id="cb41-701"><a href="#cb41-701" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"example train idx:"</span>, train_idx[:<span class="dv">8</span>].tolist())</span>
<span id="cb41-702"><a href="#cb41-702" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-703"><a href="#cb41-703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-704"><a href="#cb41-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-705"><a href="#cb41-705" aria-hidden="true" tabindex="-1"></a>Why this matters: proper splits reduce spatial leakage and inflated metrics.</span>
<span id="cb41-706"><a href="#cb41-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-707"><a href="#cb41-707" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb41-708"><a href="#cb41-708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-709"><a href="#cb41-709" aria-hidden="true" tabindex="-1"></a><span class="fu">## 1.8 Creating patch embeddings 🧠</span></span>
<span id="cb41-710"><a href="#cb41-710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-711"><a href="#cb41-711" aria-hidden="true" tabindex="-1"></a>*This section covers the patch embeddings step in our roadmap: transforming spatial patches into the vector space where models operate.*</span>
<span id="cb41-712"><a href="#cb41-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-713"><a href="#cb41-713" aria-hidden="true" tabindex="-1"></a>"This is where pixels meet the model: we project each patch into an embedding space where the model can learn patterns."</span>
<span id="cb41-714"><a href="#cb41-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-715"><a href="#cb41-715" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Flatten + linear layer (minimal version).</span>
<span id="cb41-716"><a href="#cb41-716" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Print embedding tensor shapes.</span>
<span id="cb41-717"><a href="#cb41-717" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Show a few example embedding vectors.</span>
<span id="cb41-718"><a href="#cb41-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-721"><a href="#cb41-721" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-722"><a href="#cb41-722" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-723"><a href="#cb41-723" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb41-724"><a href="#cb41-724" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> torch</span>
<span id="cb41-725"><a href="#cb41-725" aria-hidden="true" tabindex="-1"></a>    torch.manual_seed(RNG_SEED)</span>
<span id="cb41-726"><a href="#cb41-726" aria-hidden="true" tabindex="-1"></a>    B, C, P, _ <span class="op">=</span> patches.shape</span>
<span id="cb41-727"><a href="#cb41-727" aria-hidden="true" tabindex="-1"></a>    input_dim <span class="op">=</span> C <span class="op">*</span> P <span class="op">*</span> P</span>
<span id="cb41-728"><a href="#cb41-728" aria-hidden="true" tabindex="-1"></a>    embed_dim <span class="op">=</span> <span class="dv">64</span></span>
<span id="cb41-729"><a href="#cb41-729" aria-hidden="true" tabindex="-1"></a>    proj <span class="op">=</span> torch.nn.Linear(input_dim, embed_dim)</span>
<span id="cb41-730"><a href="#cb41-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-731"><a href="#cb41-731" aria-hidden="true" tabindex="-1"></a>    <span class="co"># take a tiny batch of patches</span></span>
<span id="cb41-732"><a href="#cb41-732" aria-hidden="true" tabindex="-1"></a>    sample <span class="op">=</span> torch.from_numpy(patches[:<span class="dv">4</span>]).reshape(<span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>).<span class="bu">float</span>()</span>
<span id="cb41-733"><a href="#cb41-733" aria-hidden="true" tabindex="-1"></a>    emb <span class="op">=</span> proj(sample)</span>
<span id="cb41-734"><a href="#cb41-734" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"input_dim:"</span>, input_dim, <span class="st">"embed_dim:"</span>, embed_dim, <span class="st">"emb shape:"</span>, <span class="bu">tuple</span>(emb.shape))</span>
<span id="cb41-735"><a href="#cb41-735" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"first row (rounded):"</span>, [<span class="bu">float</span>(x) <span class="cf">for</span> x <span class="kw">in</span> emb[<span class="dv">0</span>][:<span class="dv">8</span>].detach().numpy().<span class="bu">round</span>(<span class="dv">3</span>)])</span>
<span id="cb41-736"><a href="#cb41-736" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb41-737"><a href="#cb41-737" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Torch not available; skipping embeddings"</span>, e)</span>
<span id="cb41-738"><a href="#cb41-738" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-739"><a href="#cb41-739" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-740"><a href="#cb41-740" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-741"><a href="#cb41-741" aria-hidden="true" tabindex="-1"></a>Why this matters: embeddings are the model’s operating space for learning patterns.</span>
<span id="cb41-742"><a href="#cb41-742" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-743"><a href="#cb41-743" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb41-744"><a href="#cb41-744" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-745"><a href="#cb41-745" aria-hidden="true" tabindex="-1"></a><span class="fu">## 1.9 Encoding spatial &amp; temporal positions 📍</span></span>
<span id="cb41-746"><a href="#cb41-746" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-747"><a href="#cb41-747" aria-hidden="true" tabindex="-1"></a>*This section covers the final step in our roadmap: adding positional encodings so models understand spatial and temporal relationships.*</span>
<span id="cb41-748"><a href="#cb41-748" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-749"><a href="#cb41-749" aria-hidden="true" tabindex="-1"></a>"Models don't know where a patch sits in space or time unless we tell them — positional encodings add this crucial context."</span>
<span id="cb41-750"><a href="#cb41-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-751"><a href="#cb41-751" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Create 2D sinusoidal spatial encodings (row/col).</span>
<span id="cb41-752"><a href="#cb41-752" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Add temporal encodings (day‑of‑year).</span>
<span id="cb41-753"><a href="#cb41-753" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Combine with patch embeddings and inspect results.</span>
<span id="cb41-754"><a href="#cb41-754" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-757"><a href="#cb41-757" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-758"><a href="#cb41-758" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-759"><a href="#cb41-759" aria-hidden="true" tabindex="-1"></a><span class="co"># 2D sinusoidal positional encodings for (row, col)</span></span>
<span id="cb41-760"><a href="#cb41-760" aria-hidden="true" tabindex="-1"></a>rows_grid <span class="op">=</span> np.arange(ph)[:,<span class="va">None</span>].repeat(pw,<span class="dv">1</span>)</span>
<span id="cb41-761"><a href="#cb41-761" aria-hidden="true" tabindex="-1"></a>cols_grid <span class="op">=</span> np.arange(pw)[<span class="va">None</span>,:].repeat(ph,<span class="dv">0</span>)</span>
<span id="cb41-762"><a href="#cb41-762" aria-hidden="true" tabindex="-1"></a>pos2d <span class="op">=</span> np.stack([rows_grid.ravel(), cols_grid.ravel()], axis<span class="op">=</span><span class="dv">1</span>).astype(np.float32)</span>
<span id="cb41-763"><a href="#cb41-763" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-764"><a href="#cb41-764" aria-hidden="true" tabindex="-1"></a><span class="co"># Scale rows/cols to [0,1]</span></span>
<span id="cb41-765"><a href="#cb41-765" aria-hidden="true" tabindex="-1"></a>pos2d <span class="op">=</span> (pos2d <span class="op">-</span> pos2d.<span class="bu">min</span>(<span class="dv">0</span>)) <span class="op">/</span> (pos2d.ptp(<span class="dv">0</span>) <span class="op">+</span> <span class="fl">1e-6</span>)</span>
<span id="cb41-766"><a href="#cb41-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-767"><a href="#cb41-767" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple sin/cos features</span></span>
<span id="cb41-768"><a href="#cb41-768" aria-hidden="true" tabindex="-1"></a>pos_feat <span class="op">=</span> np.concatenate([np.sin(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>pos2d), np.cos(<span class="dv">2</span><span class="op">*</span>np.pi<span class="op">*</span>pos2d)], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb41-769"><a href="#cb41-769" aria-hidden="true" tabindex="-1"></a><span class="co"># time features from earlier (same for all patches here)</span></span>
<span id="cb41-770"><a href="#cb41-770" aria-hidden="true" tabindex="-1"></a>time_feat_full <span class="op">=</span> np.repeat(time_feat[<span class="va">None</span>,:], <span class="bu">len</span>(pos_feat), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb41-771"><a href="#cb41-771" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-772"><a href="#cb41-772" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"pos_feat shape:"</span>, pos_feat.shape, <span class="st">"time_feat_full shape:"</span>, time_feat_full.shape)</span>
<span id="cb41-773"><a href="#cb41-773" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-774"><a href="#cb41-774" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-777"><a href="#cb41-777" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb41-778"><a href="#cb41-778" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb41-779"><a href="#cb41-779" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine: embedding + positional + time features (toy example)</span></span>
<span id="cb41-780"><a href="#cb41-780" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb41-781"><a href="#cb41-781" aria-hidden="true" tabindex="-1"></a>    comb <span class="op">=</span> np.concatenate([</span>
<span id="cb41-782"><a href="#cb41-782" aria-hidden="true" tabindex="-1"></a>        emb.detach().numpy(),         <span class="co"># (4, 64) toy batch</span></span>
<span id="cb41-783"><a href="#cb41-783" aria-hidden="true" tabindex="-1"></a>        pos_feat[:<span class="dv">4</span>],                 <span class="co"># (4, 4)</span></span>
<span id="cb41-784"><a href="#cb41-784" aria-hidden="true" tabindex="-1"></a>        time_feat_full[:<span class="dv">4</span>]            <span class="co"># (4, 2)</span></span>
<span id="cb41-785"><a href="#cb41-785" aria-hidden="true" tabindex="-1"></a>    ], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb41-786"><a href="#cb41-786" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"combined features shape:"</span>, comb.shape)</span>
<span id="cb41-787"><a href="#cb41-787" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb41-788"><a href="#cb41-788" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Combine skipped:"</span>, e)</span>
<span id="cb41-789"><a href="#cb41-789" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb41-790"><a href="#cb41-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-791"><a href="#cb41-791" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-792"><a href="#cb41-792" aria-hidden="true" tabindex="-1"></a>Why this matters: spatial/temporal encodings provide essential context alongside pixel content.</span>
<span id="cb41-793"><a href="#cb41-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-794"><a href="#cb41-794" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb41-795"><a href="#cb41-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-796"><a href="#cb41-796" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb41-797"><a href="#cb41-797" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>We inspected raster metadata (CRS, resolution, bands) and normalized bands</span>
<span id="cb41-798"><a href="#cb41-798" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>We extracted fixed‑size patches, attached IDs/metadata, and added location/time features</span>
<span id="cb41-799"><a href="#cb41-799" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>We created minimal patch embeddings and combined them with positional/temporal encodings</span>
<span id="cb41-800"><a href="#cb41-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-801"><a href="#cb41-801" aria-hidden="true" tabindex="-1"></a><span class="fu">## Resources</span></span>
<span id="cb41-802"><a href="#cb41-802" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Quarto: https://quarto.org/docs</span>
<span id="cb41-803"><a href="#cb41-803" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Rasterio: https://rasterio.readthedocs.io/</span>
<span id="cb41-804"><a href="#cb41-804" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>NumPy: https://numpy.org/doc/</span>
<span id="cb41-805"><a href="#cb41-805" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>PyTorch: https://pytorch.org/docs/stable/index.html</span>
<span id="cb41-806"><a href="#cb41-806" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Vision Transformers (ViT): https://arxiv.org/abs/2010.11929</span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p><img src="images/geog-logo.png" alt="The Department of Geography logo" width="250"></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>This website is built with <a href="https://github.com/environmental-data-science/geog-288kc-geospatial-foundation-models"><i class="fa-brands fa-github" title="the github octocat logo" aria-label="github"></i></a> and <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>
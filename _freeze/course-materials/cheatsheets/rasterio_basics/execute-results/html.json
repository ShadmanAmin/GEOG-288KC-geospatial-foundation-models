{
  "hash": "3c70ff916f10349d0bf677077a97542e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Working with Rasterio\"\nsubtitle: \"Reading and processing satellite imagery with Python\"\njupyter: geoai\nformat: html\n---\n\n\n## Introduction to Rasterio\n\nRasterio is the essential Python library for reading and writing geospatial raster data.\n\n::: {#ba6532f1 .cell execution_count=1}\n``` {.python .cell-code}\nimport rasterio\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom rasterio.plot import show\nprint(f\"Rasterio version: {rasterio.__version__}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRasterio version: 1.4.3\n```\n:::\n:::\n\n\n## Creating Sample Data\n\nSince we may not have actual satellite imagery files, let's create some sample raster data:\n\n::: {#33dbfc60 .cell execution_count=2}\n``` {.python .cell-code}\n# Create sample raster data\ndef create_sample_raster():\n    # Create a simple 100x100 raster with some pattern\n    height, width = 100, 100\n    \n    # Create coordinate grids\n    x = np.linspace(-2, 2, width)\n    y = np.linspace(-2, 2, height)\n    X, Y = np.meshgrid(x, y)\n    \n    # Create a pattern (e.g., circular pattern)\n    data = np.sin(np.sqrt(X**2 + Y**2)) * 255\n    data = data.astype(np.uint8)\n    \n    return data\n\nsample_data = create_sample_raster()\nprint(f\"Sample data shape: {sample_data.shape}\")\nprint(f\"Data type: {sample_data.dtype}\")\nprint(f\"Data range: {sample_data.min()} to {sample_data.max()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSample data shape: (100, 100)\nData type: uint8\nData range: 7 to 254\n```\n:::\n:::\n\n\n## Working with Raster Arrays\n\n### Basic array operations\n\n::: {#a27915db .cell execution_count=3}\n``` {.python .cell-code}\n# Basic statistics\nprint(f\"Mean: {np.mean(sample_data):.2f}\")\nprint(f\"Standard deviation: {np.std(sample_data):.2f}\")\nprint(f\"Unique values: {len(np.unique(sample_data))}\")\n\n# Histogram of values\nplt.figure(figsize=(8, 4))\n\nplt.subplot(1, 2, 1)\nplt.imshow(sample_data, cmap='viridis')\nplt.title('Sample Raster Data')\nplt.colorbar()\n\nplt.subplot(1, 2, 2)\nplt.hist(sample_data.flatten(), bins=50, alpha=0.7)\nplt.title('Histogram of Values')\nplt.xlabel('Pixel Value')\nplt.ylabel('Frequency')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMean: 215.01\nStandard deviation: 46.13\nUnique values: 182\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](rasterio_basics_files/figure-html/cell-4-output-2.png){}\n:::\n:::\n\n\n### Array masking and filtering\n\n::: {#58e9121a .cell execution_count=4}\n``` {.python .cell-code}\n# Create masks\nhigh_values = sample_data > 200\nlow_values = sample_data < 50\n\nprint(f\"Pixels with high values (>200): {np.sum(high_values)}\")\nprint(f\"Pixels with low values (<50): {np.sum(low_values)}\")\n\n# Apply mask\nmasked_data = np.where(high_values, sample_data, 0)\n\nplt.figure(figsize=(12, 4))\n\nplt.subplot(1, 3, 1)\nplt.imshow(sample_data, cmap='viridis')\nplt.title('Original Data')\n\nplt.subplot(1, 3, 2)\nplt.imshow(high_values, cmap='gray')\nplt.title('High Value Mask')\n\nplt.subplot(1, 3, 3)\nplt.imshow(masked_data, cmap='viridis')\nplt.title('Masked Data')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPixels with high values (>200): 7364\nPixels with low values (<50): 76\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](rasterio_basics_files/figure-html/cell-5-output-2.png){}\n:::\n:::\n\n\n## Raster Metadata and Transforms\n\n### Understanding geospatial transforms\n\n::: {#5dec6e73 .cell execution_count=5}\n``` {.python .cell-code}\nfrom rasterio.transform import from_bounds\n\n# Create a sample transform (geographic coordinates)\nwest, south, east, north = -120.0, 35.0, -115.0, 40.0  # Bounding box\ntransform = from_bounds(west, south, east, north, 100, 100)\n\nprint(f\"Transform: {transform}\")\nprint(f\"Pixel width: {transform[0]}\")\nprint(f\"Pixel height: {abs(transform[4])}\")\n\n# Convert pixel coordinates to geographic coordinates\ndef pixel_to_geo(row, col, transform):\n    x, y = rasterio.transform.xy(transform, row, col)\n    return x, y\n\n# Example: center pixel\ncenter_row, center_col = 50, 50\ngeo_x, geo_y = pixel_to_geo(center_row, center_col, transform)\nprint(f\"Center pixel ({center_row}, {center_col}) -> Geographic: ({geo_x:.2f}, {geo_y:.2f})\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTransform: | 0.05, 0.00,-120.00|\n| 0.00,-0.05, 40.00|\n| 0.00, 0.00, 1.00|\nPixel width: 0.05\nPixel height: 0.05\nCenter pixel (50, 50) -> Geographic: (-117.47, 37.48)\n```\n:::\n:::\n\n\n### Creating profiles for writing rasters\n\n::: {#d71b35c3 .cell execution_count=6}\n``` {.python .cell-code}\n# Create a profile for writing raster data\nprofile = {\n    'driver': 'GTiff',\n    'dtype': 'uint8',\n    'nodata': None,\n    'width': 100,\n    'height': 100,\n    'count': 1,\n    'crs': 'EPSG:4326',  # WGS84 lat/lon\n    'transform': transform\n}\n\nprint(\"Raster profile:\")\nfor key, value in profile.items():\n    print(f\"  {key}: {value}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRaster profile:\n  driver: GTiff\n  dtype: uint8\n  nodata: None\n  width: 100\n  height: 100\n  count: 1\n  crs: EPSG:4326\n  transform: | 0.05, 0.00,-120.00|\n| 0.00,-0.05, 40.00|\n| 0.00, 0.00, 1.00|\n```\n:::\n:::\n\n\n## Multi-band Operations\n\n### Working with multi-band data\n\n::: {#66f8fe0a .cell execution_count=7}\n``` {.python .cell-code}\n# Create multi-band sample data (RGB-like)\ndef create_multiband_sample():\n    height, width = 100, 100\n    bands = 3\n    \n    # Create different patterns for each band\n    x = np.linspace(-2, 2, width)\n    y = np.linspace(-2, 2, height)\n    X, Y = np.meshgrid(x, y)\n    \n    # Band 1: Circular pattern\n    band1 = (np.sin(np.sqrt(X**2 + Y**2)) * 127 + 127).astype(np.uint8)\n    \n    # Band 2: Linear gradient\n    band2 = (np.linspace(0, 255, width) * np.ones((height, 1))).astype(np.uint8)\n    \n    # Band 3: Checkerboard pattern\n    band3 = ((X + Y) > 0).astype(np.uint8) * 255\n    \n    return np.stack([band1, band2, band3])\n\nmultiband_data = create_multiband_sample()\nprint(f\"Multiband shape: {multiband_data.shape}\")\nprint(f\"Shape format: (bands, height, width)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMultiband shape: (3, 100, 100)\nShape format: (bands, height, width)\n```\n:::\n:::\n\n\n### Visualizing multi-band data\n\n::: {#b95e3bd2 .cell execution_count=8}\n``` {.python .cell-code}\nfig, axes = plt.subplots(2, 2, figsize=(10, 10))\n\n# Individual bands\nfor i in range(3):\n    row, col = i // 2, i % 2\n    axes[row, col].imshow(multiband_data[i], cmap='gray')\n    axes[row, col].set_title(f'Band {i+1}')\n\n# RGB composite (transpose for matplotlib)\nrgb_composite = np.transpose(multiband_data, (1, 2, 0))\naxes[1, 1].imshow(rgb_composite)\naxes[1, 1].set_title('RGB Composite')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](rasterio_basics_files/figure-html/cell-9-output-1.png){}\n:::\n:::\n\n\n## Band Math and Indices\n\n### Calculate vegetation index (NDVI-like)\n\n::: {#9398921f .cell execution_count=9}\n``` {.python .cell-code}\n# Simulate NIR and Red bands\nnir_band = multiband_data[0].astype(np.float32)\nred_band = multiband_data[1].astype(np.float32)\n\n# Calculate NDVI-like index\n# NDVI = (NIR - Red) / (NIR + Red)\nndvi = (nir_band - red_band) / (nir_band + red_band + 1e-8)  # Small value to avoid division by zero\n\nplt.figure(figsize=(12, 4))\n\nplt.subplot(1, 3, 1)\nplt.imshow(nir_band, cmap='RdYlBu_r')\nplt.title('NIR-like Band')\nplt.colorbar()\n\nplt.subplot(1, 3, 2)\nplt.imshow(red_band, cmap='Reds')\nplt.title('Red-like Band')\nplt.colorbar()\n\nplt.subplot(1, 3, 3)\nplt.imshow(ndvi, cmap='RdYlGn', vmin=-1, vmax=1)\nplt.title('NDVI-like Index')\nplt.colorbar()\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"NDVI range: {ndvi.min():.3f} to {ndvi.max():.3f}\")\nprint(f\"NDVI mean: {np.mean(ndvi):.3f}\")\n```\n\n::: {.cell-output .cell-output-display}\n![](rasterio_basics_files/figure-html/cell-10-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNDVI range: -0.211 to 1.000\nNDVI mean: 0.353\n```\n:::\n:::\n\n\n## Resampling and Reprojection Concepts\n\n### Understanding resampling methods\n\n::: {#0bc508b9 .cell execution_count=10}\n``` {.python .cell-code}\nfrom scipy import ndimage\n\n# Demonstrate different resampling methods\noriginal = sample_data\n\n# Downsample (reduce resolution)\ndownsampled = ndimage.zoom(original, 0.5, order=1)  # Linear interpolation\n\n# Upsample (increase resolution) \nupsampled = ndimage.zoom(original, 2.0, order=1)  # Linear interpolation\n\nplt.figure(figsize=(15, 4))\n\nplt.subplot(1, 3, 1)\nplt.imshow(original, cmap='viridis')\nplt.title(f'Original ({original.shape[0]}x{original.shape[1]})')\n\nplt.subplot(1, 3, 2)\nplt.imshow(downsampled, cmap='viridis')\nplt.title(f'Downsampled ({downsampled.shape[0]}x{downsampled.shape[1]})')\n\nplt.subplot(1, 3, 3)\nplt.imshow(upsampled, cmap='viridis')\nplt.title(f'Upsampled ({upsampled.shape[0]}x{upsampled.shape[1]})')\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"Original size: {original.shape}\")\nprint(f\"Downsampled size: {downsampled.shape}\")  \nprint(f\"Upsampled size: {upsampled.shape}\")\n```\n\n::: {.cell-output .cell-output-display}\n![](rasterio_basics_files/figure-html/cell-11-output-1.png){}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal size: (100, 100)\nDownsampled size: (50, 50)\nUpsampled size: (200, 200)\n```\n:::\n:::\n\n\n## Common Rasterio Patterns\n\n### Working with windows and blocks\n\n::: {#a0bebc40 .cell execution_count=11}\n``` {.python .cell-code}\n# Simulate processing large rasters in blocks\ndef process_in_blocks(data, block_size=50):\n    \"\"\"Process data in blocks to simulate handling large rasters\"\"\"\n    height, width = data.shape\n    processed = np.zeros_like(data)\n    \n    for row in range(0, height, block_size):\n        for col in range(0, width, block_size):\n            # Define window bounds\n            row_end = min(row + block_size, height)\n            col_end = min(col + block_size, width)\n            \n            # Extract block\n            block = data[row:row_end, col:col_end]\n            \n            # Process block (example: enhance contrast)\n            processed_block = np.clip(block * 1.2, 0, 255)\n            \n            # Write back to result\n            processed[row:row_end, col:col_end] = processed_block\n            \n            print(f\"Processed block: ({row}:{row_end}, {col}:{col_end})\")\n    \n    return processed\n\n# Process sample data in blocks\nprocessed_data = process_in_blocks(sample_data, block_size=25)\n\nplt.figure(figsize=(10, 4))\n\nplt.subplot(1, 2, 1)\nplt.imshow(sample_data, cmap='viridis')\nplt.title('Original')\n\nplt.subplot(1, 2, 2)\nplt.imshow(processed_data, cmap='viridis')\nplt.title('Processed (Enhanced)')\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProcessed block: (0:25, 0:25)\nProcessed block: (0:25, 25:50)\nProcessed block: (0:25, 50:75)\nProcessed block: (0:25, 75:100)\nProcessed block: (25:50, 0:25)\nProcessed block: (25:50, 25:50)\nProcessed block: (25:50, 50:75)\nProcessed block: (25:50, 75:100)\nProcessed block: (50:75, 0:25)\nProcessed block: (50:75, 25:50)\nProcessed block: (50:75, 50:75)\nProcessed block: (50:75, 75:100)\nProcessed block: (75:100, 0:25)\nProcessed block: (75:100, 25:50)\nProcessed block: (75:100, 50:75)\nProcessed block: (75:100, 75:100)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](rasterio_basics_files/figure-html/cell-12-output-2.png){}\n:::\n:::\n\n\n## Summary\n\nKey Rasterio concepts covered:\n- Reading and understanding raster data structure\n- Working with single and multi-band imagery\n- Coordinate transforms and geospatial metadata  \n- Band math and index calculations\n- Resampling and processing techniques\n- Block-based processing for large datasets\n\n",
    "supporting": [
      "rasterio_basics_files"
    ],
    "filters": [],
    "includes": {}
  }
}
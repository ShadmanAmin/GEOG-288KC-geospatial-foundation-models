---
globs: course-materials/interactive-sessions/*
alwaysApply: false
---
# Geospatial Foundation Model Interactive Session Rules (QMD-first)

## Purpose
Guide Cursor agents to produce course materials in Quarto `.qmd` format, matching the style of `4a_dataframes.qmd` and adhering to a "from scratch" pedagogical style. All outputs should be visible and verifiable by students without asserts, using Expected Output callouts.

---

## 1) Quarto as the contract
- **File type:** All interactive sessions must be `.qmd`.
- **YAML header (required keys):**
```yaml
title: "<Session Title>"
subtitle: "<Short Topic Summary>"
jupyter: <kernel_name>
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: show
```
- **Sections (exact order):**
  1. Introduction ‚Äî 3‚Äì5 sentences, no code.
  2. Learning Objectives ‚Äî 3‚Äì6 bullets with action verbs.
  3. Session Roadmap ‚Äî Mermaid diagram showing logical phase progression (see Section 10)
  4. Setting Up ‚Äî split into small tasks:
     - Task: imports (why) ‚Üí Code (‚â§10 lines) ‚Üí (no output required)
     - Task: seeds (what is a seed) ‚Üí Code (‚â§10) ‚Üí Expected Output
     - Task: paths/constants ‚Üí Code (‚â§10) ‚Üí Expected Output
  5. **Main Content Phases** ‚Äî organized according to logical operational progression (see Section 10)
     - Use emojis to distinguish phases (üî¨ üó∫Ô∏è üß† or adapt to session content)
     - Each phase should build conceptually on the previous
     - Structure for computational and pedagogical efficiency
  6. Conclusion ‚Äî 3 bullets: What we did / Why it matters / What's next.
  7. Resources ‚Äî 3‚Äì6 links (course cheatsheets + relevant docs).

- **Chunk options:** Default `#| echo: true`. Hide boilerplate only with `code-fold: show`.

---

## 2) Tell ‚Üí Do ‚Üí Confirm (TDC) pedagogy
**Tell**: Preview the concept in plain language before code (what we expect and why)

**Do**: Run a small, focused code block that implements that idea

**Confirm**: Immediately state what happened and why it matches expectations

Notes:
- Not every block needs output (imports/constants may be silent)
- Quarto renders code output by default; avoid redundant "Expected Output" callouts
- Favor brief "What to notice"/"Why this matters" lines near outputs

## 2a) Narrative style guidelines
- **Conversational and welcoming**: Use "we," "you," "let's" to bring students along the journey
- **Professional but engaging**: Balance technical precision with approachable explanations
- **Depth without tedium**: Explain the "why" behind concepts, but keep momentum moving forward
- **Bridge abstract to concrete**: Help students see how concepts connect to real applications
- **Acknowledge complexity**: It's okay to say "this might seem tricky at first" or "here's why this step matters"
- **Sufficient explanation**: Don't rush into code‚Äîgive students enough context to understand what's coming and why it matters

## 3) No asserts ‚Äî use visible, checkable output
Let Quarto show the outputs; keep them minimal and interpretable (shapes, small plots, concise prints). Include a quick recovery tip when helpful:

```markdown
::: callout-tip
**If your output differs:**
- Re-check `DATA_PATH` and CRS
- Confirm normalization step ran
- Restart Kernel & Run All
:::
```

---

## 4) Code style for "from scratch"
- **Pattern per step:**
  1. Load/transform in small chunks (‚â§20 lines)
  2. Print shapes/CRS/stats
  3. Plot small outputs
  4. Expected Output callout
- **Top-of-file constants:**
```python
DATA_PATH = "data/tiny_aoi.tif"
PATCH_SIZE = 64
CRS_TARGET = None
RNG_SEED = 7
```
- **Determinism:** Set and print RNG seeds.
- **Runtime ceiling:** <15s CPU per section.

---

## 5) Optional Exploration
Mark as optional and safe to skip:
```markdown
## Optional Exploration (safe to skip)
This mini-task is independent and will not affect later outputs.
```

---

## 6) Geospatial hygiene
Always print or display:
- CRS string
- Transform summary
- Resolution (m/px)
- Band names/units
- Resampling method
- Normalization info (per-band min/max)

---

## 7) End-of-session checklist
- Key printed lines to confirm correctness
- Final figure or miniature screenshot

---

## 8) Naming conventions
- Two-part identifier: `4a_dataframes.qmd`, `2b_patching.qmd`
- Titles start with verb + domain noun

---

## 9) Agent prompt snippets
- Confirm `jupyter:` kernel name
- Ask whether to reproject or keep-native CRS
- Confirm `DATA_PATH` to tiny demo file
- Allow **one** optional exploration block

Require:
- Print shape/CRS/min‚Äìmax after each transform
- Expected Output callout per section

---

## 9) Accessibility
- Alt-text for images
- High-contrast plots
- Include colorbars for single-band plots
- Avoid red‚Äìgreen contrasts

---

## 10) Logical Session Organization Principles

**CRITICAL**: Interactive sessions must follow a logical progression that optimizes pedagogical, operational, and implementation benefits:

### Core Organizational Principle
Structure sessions around **natural operational phases** that:
- **Build conceptual complexity gradually** (simple ‚Üí complex operations)
- **Optimize computational efficiency** (expensive operations early, before creating many objects)
- **Enable modular implementation** (each phase can be developed/tested independently)
- **Facilitate debugging** (easier to isolate issues to specific processing phases)

### Example: Data Processing Sessions (like session1_data_foundations)
```
üî¨ Phase 1: Fundamental Operations
- Raw data inspection and understanding
- Basic transformations (normalization, enhancement)
- Expensive operations done once on full data

üó∫Ô∏è Phase 2: Structural Transformations  
- Create derived structures (patches, segments, features)
- Add contextual metadata and relationships
- Spatial/temporal/semantic operations

üß† Phase 3: Model Integration
- Transform to model-ready formats
- Add model-specific encodings
- Final verification and validation
```

### Other Session Types Should Follow Similar Logic:
- **Architecture sessions**: Basic components ‚Üí Complex assemblies ‚Üí Full models
- **Training sessions**: Data setup ‚Üí Training loop ‚Üí Evaluation/analysis  
- **Deployment sessions**: Model preparation ‚Üí Interface development ‚Üí Testing/validation

### Required Roadmap Diagram
Each session must include a horizontal Mermaid flowchart showing the logical phases with arrows connecting steps. Adapt the structure to your session's content:
```mermaid
flowchart LR
    subgraph Phase1 ["üî¨ Phase 1: [Fundamental Operations]"]
        A["Step"] --> B["Step"]
    end
    subgraph Phase2 ["üó∫Ô∏è Phase 2: [Structural Transformations]"] 
        C["Step"] --> D["Step"]
    end
    subgraph Phase3 ["üß† Phase 3: [Integration/Application]"]
        E["Step"] --> F["Step"]
    end
    Phase1 --> Phase2
    Phase2 --> Phase3
```

---

# QMD Skeleton Template

```markdown
---
title: "Interactive Session"
subtitle: "<Concise Topic>"
jupyter: eds217_2025
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: show
---

## Introduction
Brief context for the topic.

## Learning Objectives
- Objective 1
- Objective 2

## Session Roadmap
```{mermaid}
flowchart LR
    subgraph Phase1 ["üî¨ Phase 1: [Fundamental Operations]"]
        A["Step A"] --> B["Step B"]
    end
    subgraph Phase2 ["üó∫Ô∏è Phase 2: [Structural Transformations]"] 
        C["Step C"] --> D["Step D"]
    end
    subgraph Phase3 ["üß† Phase 3: [Integration/Application]"]
        E["Step E"] --> F["Step F"]
    end
    Phase1 --> Phase2
    Phase2 --> Phase3
```

## Setting Up
```{python}
#| echo: true
import numpy as np, rasterio as rio, matplotlib.pyplot as plt, torch, random
np.random.seed(7); random.seed(7); torch.manual_seed(7)

DATA_PATH = "data/tiny_aoi.tif"
PATCH_SIZE = 64
CRS_TARGET = None
print("RNG seeds set: 7")
```

## üî¨ Phase 1: [Fundamental Operations]

### 1.1 Load and Inspect Data
```{python}
#| echo: true
with rio.open(DATA_PATH) as src:
    arr = src.read()
    crs = src.crs
    transform = src.transform
print("shape:", arr.shape, "| dtype:", arr.dtype)
print("CRS:", crs)
print("pixel size:", transform.a, transform.e)
print("per-band min/max:", [(float(b.min()), float(b.max())) for b in arr])
```

### 1.2 Basic Transformations
...

## üó∫Ô∏è Phase 2: [Structural Transformations]

### 2.1 Create Derived Structures
...

### 2.2 Add Context and Relationships
...

## üß† Phase 3: [Integration/Application]

### 3.1 Model-Ready Preparation
...

### 3.2 Final Verification
...

## Conclusion
- What we did
- Why it matters
- What's next

## Resources
- Link 1
- Link 2
```

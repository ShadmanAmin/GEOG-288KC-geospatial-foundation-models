---
title: "Earth Engine Basics"
subtitle: "Working with Google Earth Engine"
jupyter: geoai
format: html
---

## Introduction to Earth Engine

Google Earth Engine is a cloud-based platform for planetary-scale geospatial analysis using Google's computing infrastructure.

```{python}
import ee
import geemap

# Initialize Earth Engine
try:
    ee.Initialize()
    print("Earth Engine initialized successfully!")
except Exception as e:
    print(f"Error initializing Earth Engine: {e}")
    print("Make sure you have authenticated with 'ee.Authenticate()'")
```

## Authentication and Setup

### First-time setup
```{python}
# Run this once to authenticate (uncomment if needed)
# ee.Authenticate()

# Alternative initialization for service accounts
# ee.Initialize(ee.ServiceAccountCredentials('your-email@project.iam.gserviceaccount.com', 'path/to/key.json'))
```

### Basic Earth Engine objects
```{python}
# Get information about Earth Engine
print(f"Earth Engine version: {ee.__version__}")

# Basic geometry objects
point = ee.Geometry.Point([0, 0])
rectangle = ee.Geometry.Rectangle([0, 0, 1, 1])
polygon = ee.Geometry.Polygon([[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]])

print(f"Point coordinates: {point.coordinates().getInfo()}")
print(f"Rectangle area: {rectangle.area().getInfo()} square meters")
```

## Working with Image Collections

### Landsat collections
```{python}
# Landsat 8 Collection 2 Surface Reflectance
landsat = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')

print(f"Landsat collection size: {landsat.size().getInfo()}")

# Filter by date and location
san_francisco = ee.Geometry.Point([-122.4194, 37.7749])
filtered = (landsat
           .filterDate('2020-01-01', '2020-12-31')
           .filterBounds(san_francisco)
           .filter(ee.Filter.lt('CLOUD_COVER', 20)))

print(f"Filtered collection size: {filtered.size().getInfo()}")
```

### Sentinel-2 collections
```{python}
# Sentinel-2 Surface Reflectance
sentinel2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')

s2_filtered = (sentinel2
              .filterDate('2020-06-01', '2020-08-31')
              .filterBounds(san_francisco)
              .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10)))

print(f"Sentinel-2 filtered collection size: {s2_filtered.size().getInfo()}")

# Get first image info
first_image = s2_filtered.first()
print(f"First image ID: {first_image.get('system:id').getInfo()}")
print(f"First image date: {first_image.date().format('YYYY-MM-dd').getInfo()}")
```

## Image Processing and Analysis

### Basic image operations
```{python}
# Get a single Landsat image
image = landsat.filterBounds(san_francisco).first()

# Get image properties
properties = image.propertyNames()
print(f"Image properties: {properties.getInfo()[:10]}")  # Show first 10

# Get band names
bands = image.bandNames()
print(f"Band names: {bands.getInfo()}")

# Select specific bands
rgb_bands = image.select(['SR_B4', 'SR_B3', 'SR_B2'])  # Red, Green, Blue
print(f"RGB bands: {rgb_bands.bandNames().getInfo()}")
```

### Calculate vegetation indices
```{python}
def calculate_ndvi(image):
    """Calculate NDVI from Landsat 8 image"""
    nir = image.select('SR_B5')  # Near-infrared
    red = image.select('SR_B4')  # Red
    ndvi = nir.subtract(red).divide(nir.add(red)).rename('NDVI')
    return image.addBands(ndvi)

def calculate_ndwi(image):
    """Calculate NDWI (water index)"""
    green = image.select('SR_B3')  # Green
    nir = image.select('SR_B5')    # Near-infrared
    ndwi = green.subtract(nir).divide(green.add(nir)).rename('NDWI')
    return image.addBands(ndwi)

# Apply to an image
image_with_indices = calculate_ndvi(image)
image_with_indices = calculate_ndwi(image_with_indices)

print(f"Bands after adding indices: {image_with_indices.bandNames().getInfo()}")
```

### Image mosaicking and compositing
```{python}
# Create a median composite
median_composite = filtered.median()

# Create a quality mosaic (least cloudy pixels)
quality_mosaic = filtered.qualityMosaic('SR_B1')

# Cloud masking for Landsat 8
def mask_clouds_landsat(image):
    """Mask clouds and cloud shadows in Landsat 8 images"""
    qa = image.select('QA_PIXEL')
    
    # Bits 3 and 4 are cloud and cloud shadow
    cloud_bit_mask = 1 << 3
    cloud_shadow_bit_mask = 1 << 4
    
    # Both bits should be set to zero, indicating clear conditions
    mask = qa.bitwiseAnd(cloud_bit_mask).eq(0).And(
           qa.bitwiseAnd(cloud_shadow_bit_mask).eq(0))
    
    return image.updateMask(mask)

# Apply cloud masking
cloud_free = filtered.map(mask_clouds_landsat)
cloud_free_composite = cloud_free.median()

print("Cloud masking applied successfully")
```

## Geospatial Operations

### Zonal statistics
```{python}
# Define a region of interest
roi = san_francisco.buffer(10000)  # 10km buffer around SF

# Calculate mean NDVI over the region
ndvi_image = image_with_indices.select('NDVI')
mean_ndvi = ndvi_image.reduceRegion(
    reducer=ee.Reducer.mean(),
    geometry=roi,
    scale=30,  # Landsat pixel size
    maxPixels=1e9
)

print(f"Mean NDVI: {mean_ndvi.getInfo()}")

# Time series analysis
def add_date_band(image):
    """Add date as a band"""
    date = ee.Date(image.get('system:time_start'))
    date_band = ee.Image.constant(date.millis()).rename('date')
    return image.addBands(date_band)

# Create time series of NDVI
time_series = (landsat
               .filterBounds(roi)
               .filterDate('2020-01-01', '2020-12-31')
               .filter(ee.Filter.lt('CLOUD_COVER', 20))
               .map(mask_clouds_landsat)
               .map(calculate_ndvi)
               .map(add_date_band))

print(f"Time series size: {time_series.size().getInfo()}")
```

### Export operations
```{python}
# Export parameters
export_params = {
    'image': median_composite.select(['SR_B4', 'SR_B3', 'SR_B2']),
    'description': 'landsat_rgb_composite',
    'scale': 30,
    'region': roi,
    'maxPixels': 1e9,
    'crs': 'EPSG:4326'
}

# Create export task (don't actually run)
task = ee.batch.Export.image.toDrive(**export_params)
print(f"Export task created: {task}")
print("To actually export, run: task.start()")

# Export to Google Cloud Storage
# task_gcs = ee.batch.Export.image.toCloudStorage(
#     image=median_composite.select(['SR_B4', 'SR_B3', 'SR_B2']),
#     description='landsat_rgb_to_gcs',
#     bucket='your-bucket-name',
#     fileNamePrefix='landsat_composite',
#     scale=30,
#     region=roi
# )
```

## Visualization with Geemap

### Interactive mapping
```{python}
# Create an interactive map
Map = geemap.Map(center=[37.7749, -122.4194], zoom=10)

# Add layers
vis_params_rgb = {
    'bands': ['SR_B4', 'SR_B3', 'SR_B2'],
    'min': 7000,
    'max': 12000,
    'gamma': 1.2
}

vis_params_ndvi = {
    'min': -1,
    'max': 1,
    'palette': ['blue', 'white', 'green']
}

# Add image layers
Map.addLayer(median_composite, vis_params_rgb, 'Landsat RGB')
Map.addLayer(image_with_indices.select('NDVI'), vis_params_ndvi, 'NDVI')

# Add geometry
Map.addLayer(roi, {'color': 'red'}, 'ROI')

# Display the map (in Jupyter notebooks)
# Map
print("Interactive map created with Geemap")
```

### Chart creation
```{python}
# Time series chart
def create_ndvi_time_series():
    """Create NDVI time series chart"""
    chart_data = time_series.select(['NDVI', 'date']).reduceRegion(
        reducer=ee.Reducer.mean(),
        geometry=roi,
        scale=30
    )
    return chart_data

print("NDVI time series data prepared for charting")
```

## Common Patterns and Best Practices

### Efficient filtering
```{python}
# Chain filters for efficiency
efficient_collection = (ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
                        .filterDate('2020-01-01', '2020-12-31')
                        .filterBounds(roi)
                        .filter(ee.Filter.lt('CLOUD_COVER', 20))
                        .limit(10))  # Limit results for faster processing

print(f"Efficient collection size: {efficient_collection.size().getInfo()}")
```

### Error handling
```{python}
def safe_calculation(image):
    """Safely perform calculations with error handling"""
    try:
        ndvi = calculate_ndvi(image)
        return ndvi
    except Exception as e:
        print(f"Error in calculation: {e}")
        return image

# Apply safe calculation
safe_result = efficient_collection.map(safe_calculation)
print("Safe calculation applied to collection")
```

### Memory optimization
```{python}
# Use .getInfo() sparingly - it brings data to client
# Instead, use server-side operations when possible

# Good: Server-side operation
collection_size = landsat.size()
print(f"Collection size (server-side): {collection_size}")

# Use .getInfo() only when necessary
actual_size = collection_size.getInfo()
print(f"Actual size: {actual_size}")
```

## Summary

Key Earth Engine concepts:
- **ImageCollections**: Groups of satellite images
- **Filtering**: Date, bounds, and metadata filters
- **Mapping**: Apply functions to all images in collection
- **Reducers**: Aggregate data spatially or temporally
- **Export**: Save results to Drive, Cloud Storage, or Assets
- **Server vs Client**: Keep processing on Google's servers when possible
